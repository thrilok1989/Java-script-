"""
Unified ML Trading Signal
==========================
Combines ALL ML modules into a SINGLE trading signal

Modules Combined:
1. ML Market Regime Detection
2. XGBoost Prediction (BUY/SELL/HOLD)
3. Volatility Regime
4. OI Trap Detection
5. CVD Delta Imbalance
6. Liquidity Gravity Analysis
7. Institutional vs Retail Detection

Output: Single unified trading signal with confidence score
"""

import streamlit as st
import pandas as pd
import numpy as np
import requests
from datetime import datetime
from typing import Dict, Any, Optional, Tuple
from dataclasses import dataclass
import logging

logger = logging.getLogger(__name__)


def send_ml_signal_telegram(signal, spot_price: float = None):
    """
    Send ML Signal to Telegram when BUY/SELL signal is generated
    """
    try:
        # Get Telegram credentials from secrets
        bot_token = st.secrets.get("TELEGRAM_BOT_TOKEN", "")
        chat_id = st.secrets.get("TELEGRAM_CHAT_ID", "")

        if not bot_token or not chat_id:
            return False, "Telegram not configured"

        # Check if we already sent this signal (avoid duplicates)
        signal_key = f"{signal.signal}_{signal.atm_strike}_{signal.timestamp.strftime('%Y%m%d%H%M')}"
        if 'last_ml_telegram_signal' in st.session_state:
            if st.session_state.last_ml_telegram_signal == signal_key:
                return False, "Signal already sent"

        # Build the message
        if signal.signal in ['STRONG BUY', 'BUY']:
            emoji = "ğŸŸ¢ğŸ“ˆ"
            option_type = "CALL"
            option_ltp = signal.atm_call_ltp
        elif signal.signal in ['STRONG SELL', 'SELL']:
            emoji = "ğŸ”´ğŸ“‰"
            option_type = "PUT"
            option_ltp = signal.atm_put_ltp
        else:
            return False, "No actionable signal"

        # Format targets
        targets_str = ""
        if signal.targets:
            for i, t in enumerate(signal.targets, 1):
                targets_str += f"T{i}: â‚¹{t:,.0f}\n"

        # Build message
        message = f"""
{emoji} *ML TRADING SIGNAL* {emoji}

ğŸ¯ *Signal:* {signal.signal}
ğŸ“Š *Confidence:* {signal.confidence:.0f}%
âš ï¸ *Risk Level:* {signal.risk_level}

ğŸ’° *Trade Setup:*
â€¢ ATM Strike: â‚¹{signal.atm_strike:,.0f}
â€¢ Option: BUY {option_type}
â€¢ LTP: â‚¹{option_ltp:,.2f}

ğŸ“ˆ *Strategy:* {signal.recommended_strategy}

ğŸ¯ *Entry Zone:* â‚¹{signal.entry_zone[0]:,.0f} - â‚¹{signal.entry_zone[1]:,.0f}
ğŸ›‘ *Stop Loss:* â‚¹{signal.stop_loss:,.0f}

ğŸ¯ *Targets:*
{targets_str}
ğŸ“Š *Market Regime:* {signal.regime}
ğŸ“‰ *Volatility:* {signal.volatility_state}
â° *Expiry:* {signal.days_to_expiry:.1f} days

âš¡ _Generated by ML Signal Engine_
"""

        # Send to Telegram
        url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
        payload = {
            "chat_id": chat_id,
            "text": message,
            "parse_mode": "Markdown",
            "disable_web_page_preview": True
        }
        response = requests.post(url, json=payload, timeout=10)

        if response.status_code == 200:
            # Store signal key to avoid duplicates
            st.session_state.last_ml_telegram_signal = signal_key
            return True, "Signal sent to Telegram!"
        else:
            return False, f"Failed: {response.status_code}"

    except Exception as e:
        logger.error(f"Telegram send error: {e}")
        return False, f"Error: {str(e)}"


@dataclass
class UnifiedSignal:
    """Unified Trading Signal"""
    signal: str  # "STRONG BUY", "BUY", "HOLD", "SELL", "STRONG SELL"
    confidence: float  # 0-100

    # Component scores
    regime_score: float  # -100 to +100
    xgboost_score: float  # -100 to +100
    volatility_score: float  # 0 to 100
    oi_trap_score: float  # -100 to +100
    cvd_score: float  # -100 to +100
    liquidity_score: float  # -100 to +100
    expiry_score: float  # 0 to 100 (risk score)

    # Details
    regime: str
    volatility_state: str
    trap_warning: str
    recommended_strategy: str

    # Expiry analysis
    days_to_expiry: float
    expiry_spike_probability: float
    expiry_spike_type: str
    expiry_warning: str

    # Risk metrics
    risk_level: str  # "LOW", "MEDIUM", "HIGH", "EXTREME"
    position_size_multiplier: float  # 0.25 to 1.5

    # Entry/Exit levels
    entry_zone: Tuple[float, float]
    stop_loss: float
    targets: list

    # Reasoning
    bullish_reasons: list
    bearish_reasons: list

    # ATM Option LTP for trade recommendation
    atm_strike: float = 0.0
    atm_call_ltp: float = 0.0
    atm_put_ltp: float = 0.0

    timestamp: datetime = None


class UnifiedMLSignalGenerator:
    """
    Generates a unified trading signal from all ML modules
    """

    def __init__(self):
        """Initialize the signal generator"""
        self.modules_loaded = {}
        self._load_modules()

    def _load_modules(self):
        """Load all ML modules"""
        # ML Market Regime
        try:
            from src.ml_market_regime import MLMarketRegimeDetector
            self.regime_detector = MLMarketRegimeDetector()
            self.modules_loaded['regime'] = True
        except ImportError:
            self.modules_loaded['regime'] = False
            self.regime_detector = None

        # XGBoost Analyzer
        try:
            from src.xgboost_ml_analyzer import XGBoostMLAnalyzer
            self.xgboost_analyzer = XGBoostMLAnalyzer()
            self.modules_loaded['xgboost'] = True
        except ImportError:
            self.modules_loaded['xgboost'] = False
            self.xgboost_analyzer = None

        # Volatility Regime
        try:
            from src.volatility_regime import VolatilityRegimeDetector
            self.volatility_detector = VolatilityRegimeDetector()
            self.modules_loaded['volatility'] = True
        except ImportError:
            self.modules_loaded['volatility'] = False
            self.volatility_detector = None

        # OI Trap Detection
        try:
            from src.oi_trap_detection import OITrapDetector
            self.oi_trap_detector = OITrapDetector()
            self.modules_loaded['oi_trap'] = True
        except ImportError:
            self.modules_loaded['oi_trap'] = False
            self.oi_trap_detector = None

        # CVD Analyzer
        try:
            from src.cvd_delta_imbalance import CVDAnalyzer
            self.cvd_analyzer = CVDAnalyzer()
            self.modules_loaded['cvd'] = True
        except ImportError:
            self.modules_loaded['cvd'] = False
            self.cvd_analyzer = None

        # Liquidity Analyzer
        try:
            from src.liquidity_gravity import LiquidityGravityAnalyzer
            self.liquidity_analyzer = LiquidityGravityAnalyzer()
            self.modules_loaded['liquidity'] = True
        except ImportError:
            self.modules_loaded['liquidity'] = False
            self.liquidity_analyzer = None

        # Institutional Detector
        try:
            from src.institutional_retail_detector import InstitutionalRetailDetector
            self.institutional_detector = InstitutionalRetailDetector()
            self.modules_loaded['institutional'] = True
        except ImportError:
            self.modules_loaded['institutional'] = False
            self.institutional_detector = None

    def generate_signal(
        self,
        df: pd.DataFrame,
        option_chain: Optional[Dict] = None,
        vix_current: Optional[float] = None,
        spot_price: Optional[float] = None,
        bias_results: Optional[Dict] = None
    ) -> UnifiedSignal:
        """
        Generate unified trading signal from all ML modules

        Args:
            df: Price DataFrame with OHLCV
            option_chain: Option chain data
            vix_current: Current VIX value
            spot_price: Current spot price
            bias_results: Results from Bias Analysis Pro

        Returns:
            UnifiedSignal with combined analysis
        """
        # Ensure we have a valid spot_price
        if not spot_price or spot_price <= 0:
            # Try to get from DataFrame
            if df is not None and len(df) > 0:
                close_col = 'Close' if 'Close' in df.columns else 'close' if 'close' in df.columns else None
                if close_col:
                    spot_price = float(df[close_col].iloc[-1])

        # Store spot_price in session state for other components
        if spot_price and spot_price > 0:
            st.session_state['computed_spot_price'] = spot_price
            st.session_state['nifty_spot'] = spot_price

        # Initialize scores
        scores = {
            'regime': 0,
            'xgboost': 0,
            'volatility': 50,  # Neutral default
            'oi_trap': 0,
            'cvd': 0,
            'liquidity': 0,
            'institutional': 0
        }

        bullish_reasons = []
        bearish_reasons = []

        regime_name = "Unknown"
        volatility_state = "Normal"
        trap_warning = "None"
        strategy = "Wait for confirmation"

        # Ensure ATR column exists (handle both 'High'/'Low' and 'high'/'low' columns)
        if 'ATR' not in df.columns:
            df = df.copy()
            # Check for column names (could be 'High' or 'high')
            high_col = 'High' if 'High' in df.columns else 'high' if 'high' in df.columns else None
            low_col = 'Low' if 'Low' in df.columns else 'low' if 'low' in df.columns else None
            if high_col and low_col:
                df['ATR'] = df[high_col] - df[low_col]
            else:
                df['ATR'] = 50  # Default ATR if columns missing

        # 1. ML Market Regime
        regime_result = None
        if self.regime_detector:
            try:
                regime_result = self.regime_detector.detect_regime(df)
                regime_name = regime_result.regime

                # Store full regime result in session state for display
                st.session_state['ml_regime_result'] = {
                    'regime': regime_result.regime,
                    'confidence': regime_result.confidence,
                    'trend_strength': regime_result.trend_strength,
                    'volatility_state': regime_result.volatility_state,
                    'market_phase': regime_result.market_phase,
                    'recommended_strategy': regime_result.recommended_strategy,
                    'optimal_timeframe': regime_result.optimal_timeframe,
                    'signals': regime_result.signals if hasattr(regime_result, 'signals') else [],
                    'trading_sentiment': getattr(regime_result, 'trading_sentiment', 'NEUTRAL'),
                    'sentiment_confidence': getattr(regime_result, 'sentiment_confidence', 0),
                    'sentiment_score': getattr(regime_result, 'sentiment_score', 0),
                    'support_resistance': getattr(regime_result, 'support_resistance', {}),
                    'entry_exit_signals': getattr(regime_result, 'entry_exit_signals', {})
                }

                # Convert regime to score (-100 to +100)
                if 'Up' in regime_name or 'BULLISH' in regime_name.upper():
                    scores['regime'] = min(regime_result.trend_strength * 1.5, 100)
                    bullish_reasons.append(f"Regime: {regime_name} (Trend: {regime_result.trend_strength:.0f}%)")
                elif 'Down' in regime_name or 'BEARISH' in regime_name.upper():
                    scores['regime'] = -min(regime_result.trend_strength * 1.5, 100)
                    bearish_reasons.append(f"Regime: {regime_name} (Trend: {regime_result.trend_strength:.0f}%)")
                else:
                    scores['regime'] = 0

                volatility_state = regime_result.volatility_state
                strategy = regime_result.recommended_strategy

            except Exception as e:
                logger.warning(f"Regime detection failed: {e}")

        # 2. Volatility Analysis
        if self.volatility_detector and vix_current:
            try:
                vol_result = self.volatility_detector.detect(df, vix_current)

                # Volatility affects position sizing, not direction
                if hasattr(vol_result, 'regime'):
                    vol_regime = str(vol_result.regime)
                    if 'Low' in vol_regime:
                        scores['volatility'] = 80
                        bullish_reasons.append("Low volatility - Good for trending")
                    elif 'High' in vol_regime or 'Extreme' in vol_regime:
                        scores['volatility'] = 20
                        bearish_reasons.append("High volatility - Reduce position")
                    else:
                        scores['volatility'] = 50

            except Exception as e:
                logger.warning(f"Volatility detection failed: {e}")

        # 3. OI Trap Detection
        if self.oi_trap_detector and option_chain and spot_price:
            try:
                oi_result = self.oi_trap_detector.detect(option_chain, spot_price)

                if hasattr(oi_result, 'trap_detected') and oi_result.trap_detected:
                    trap_type = getattr(oi_result, 'trap_type', 'Unknown')
                    trap_warning = f"{trap_type} detected!"

                    if trap_type == 'BEAR_TRAP':
                        scores['oi_trap'] = 50  # Bullish
                        bullish_reasons.append(f"Bear trap detected - Expect reversal up")
                    elif trap_type == 'BULL_TRAP':
                        scores['oi_trap'] = -50  # Bearish
                        bearish_reasons.append(f"Bull trap detected - Expect reversal down")
                else:
                    trap_warning = "No trap"

            except Exception as e:
                logger.warning(f"OI Trap detection failed: {e}")

        # 4. CVD Analysis
        if self.cvd_analyzer:
            try:
                cvd_result = self.cvd_analyzer.analyze(df)

                if hasattr(cvd_result, 'bias'):
                    if cvd_result.bias == 'Bullish':
                        scores['cvd'] = min(getattr(cvd_result, 'strength', 50), 100)
                        bullish_reasons.append(f"CVD Bullish (Strength: {scores['cvd']:.0f}%)")
                    elif cvd_result.bias == 'Bearish':
                        scores['cvd'] = -min(getattr(cvd_result, 'strength', 50), 100)
                        bearish_reasons.append(f"CVD Bearish (Strength: {abs(scores['cvd']):.0f}%)")

            except Exception as e:
                logger.warning(f"CVD analysis failed: {e}")

        # 5. Liquidity Analysis
        if self.liquidity_analyzer and option_chain and spot_price and isinstance(spot_price, (int, float)):
            try:
                liq_result = self.liquidity_analyzer.analyze(option_chain, spot_price)

                if hasattr(liq_result, 'gravity_center'):
                    gravity = liq_result.gravity_center
                    # Validate gravity is numeric before comparison
                    if gravity and isinstance(gravity, (int, float)) and not isinstance(gravity, bool):
                        if gravity > spot_price:
                            scores['liquidity'] = 30  # Price likely to move up
                            bullish_reasons.append(f"Liquidity center above price (â‚¹{gravity:,.0f})")
                        elif gravity < spot_price:
                            scores['liquidity'] = -30  # Price likely to move down
                            bearish_reasons.append(f"Liquidity center below price (â‚¹{gravity:,.0f})")

            except Exception as e:
                logger.warning(f"Liquidity analysis failed: {e}")

        # 6. Institutional Flow
        if self.institutional_detector:
            try:
                inst_result = self.institutional_detector.detect(df)

                if hasattr(inst_result, 'dominant_participant'):
                    participant = str(inst_result.dominant_participant)
                    if 'Institutional' in participant:
                        # Follow institutional money
                        if hasattr(inst_result, 'institutional_bias'):
                            if inst_result.institutional_bias == 'Bullish':
                                scores['institutional'] = 40
                                bullish_reasons.append("Institutional buying detected")
                            elif inst_result.institutional_bias == 'Bearish':
                                scores['institutional'] = -40
                                bearish_reasons.append("Institutional selling detected")

            except Exception as e:
                logger.warning(f"Institutional detection failed: {e}")

        # 7. XGBoost Prediction (if model is trained)
        if self.xgboost_analyzer and hasattr(self.xgboost_analyzer, 'is_trained') and self.xgboost_analyzer.is_trained:
            try:
                xgb_result = self.xgboost_analyzer.predict(df, bias_results, option_chain)

                if hasattr(xgb_result, 'prediction'):
                    if xgb_result.prediction == 'BUY':
                        scores['xgboost'] = xgb_result.confidence
                        bullish_reasons.append(f"XGBoost: BUY ({xgb_result.confidence:.0f}%)")
                    elif xgb_result.prediction == 'SELL':
                        scores['xgboost'] = -xgb_result.confidence
                        bearish_reasons.append(f"XGBoost: SELL ({xgb_result.confidence:.0f}%)")

            except Exception as e:
                logger.warning(f"XGBoost prediction failed: {e}")

        # 8. ALL-DAY SPIKE DETECTION (from NIFTY Option Screener)
        # This overrides range-bound signals when high probability spikes are detected
        scores['spike'] = 0
        spike_detected = False
        spike_direction = None
        spike_probability = 0

        try:
            # Get spike data from session state (set by NIFTY Option Screener)
            if 'all_day_spike_result' in st.session_state and st.session_state.all_day_spike_result:
                spike_result = st.session_state.all_day_spike_result

                # Check for active spikes
                active_spikes = spike_result.get('active_spikes', [])
                overall_spike_prob = spike_result.get('overall_spike_probability', 0)
                dominant_direction = spike_result.get('dominant_direction', 'NEUTRAL')

                if active_spikes and overall_spike_prob > 40:
                    spike_detected = True
                    spike_probability = overall_spike_prob

                    # Get highest probability spike
                    best_spike = max(active_spikes, key=lambda x: x.get('probability', 0))
                    spike_type = best_spike.get('type', 'Unknown')
                    spike_prob = best_spike.get('probability', 0)
                    spike_dir = best_spike.get('direction', dominant_direction)

                    # Score based on direction
                    if spike_dir == 'UP' or spike_dir == 'BULLISH':
                        scores['spike'] = min(spike_prob * 1.2, 100)
                        spike_direction = 'UP'
                        bullish_reasons.append(f"ğŸš€ {spike_type} Spike: {spike_prob:.0f}% - Expect UP move")
                    elif spike_dir == 'DOWN' or spike_dir == 'BEARISH':
                        scores['spike'] = -min(spike_prob * 1.2, 100)
                        spike_direction = 'DOWN'
                        bearish_reasons.append(f"ğŸ“‰ {spike_type} Spike: {spike_prob:.0f}% - Expect DOWN move")

                    # If spike probability is very high (>70%), override regime
                    if spike_prob > 70:
                        if spike_direction == 'UP':
                            regime_name = f"SPIKE UP ({spike_prob:.0f}%)"
                            strategy = f"Buy {spike_type} - High probability UP spike"
                        else:
                            regime_name = f"SPIKE DOWN ({spike_prob:.0f}%)"
                            strategy = f"Sell {spike_type} - High probability DOWN spike"

                # Check support/resistance spikes
                support_spike = spike_result.get('support_spike', {})
                resistance_spike = spike_result.get('resistance_spike', {})

                if support_spike and support_spike.get('probability', 0) > 50:
                    supp_prob = support_spike['probability']
                    scores['spike'] += min(supp_prob * 0.5, 40)
                    bullish_reasons.append(f"ğŸ›¡ï¸ Support Spike: {supp_prob:.0f}% at â‚¹{support_spike.get('level', 0):,.0f}")

                if resistance_spike and resistance_spike.get('probability', 0) > 50:
                    res_prob = resistance_spike['probability']
                    scores['spike'] -= min(res_prob * 0.5, 40)
                    bearish_reasons.append(f"ğŸ§± Resistance Spike: {res_prob:.0f}% at â‚¹{resistance_spike.get('level', 0):,.0f}")

        except Exception as e:
            logger.warning(f"Spike detection integration failed: {e}")

        # Calculate weighted final score
        weights = {
            'regime': 0.20,      # 20% (reduced to make room for spike)
            'xgboost': 0.15,     # 15% (if trained)
            'volatility': 0.10,  # 10%
            'oi_trap': 0.15,     # 15%
            'cvd': 0.10,         # 10%
            'liquidity': 0.10,   # 10%
            'institutional': 0.05,  # 5%
            'spike': 0.15        # 15% - NEW spike detection weight
        }

        # Adjust weights if XGBoost not trained
        if not (self.xgboost_analyzer and getattr(self.xgboost_analyzer, 'is_trained', False)):
            weights['xgboost'] = 0
            weights['regime'] = 0.25
            weights['oi_trap'] = 0.20
            weights['cvd'] = 0.15
            weights['spike'] = 0.20  # Increase spike weight when XGBoost not available

        # If high probability spike detected, boost spike weight significantly
        if spike_detected and spike_probability > 60:
            weights['spike'] = 0.30  # 30% weight for strong spikes
            weights['regime'] = 0.15  # Reduce regime weight

        # Normalize weights
        total_weight = sum(weights.values())
        if total_weight > 0:
            weights = {k: v / total_weight for k, v in weights.items()}

        # Calculate final score (only use keys that exist in both scores and weights)
        final_score = sum(scores.get(k, 0) * weights.get(k, 0) for k in weights.keys())

        # BOOST: If spike is detected with high probability, amplify the signal
        if spike_detected and spike_probability > 50:
            if spike_direction == 'UP':
                final_score += spike_probability * 0.5  # Add up to 50 points
            elif spike_direction == 'DOWN':
                final_score -= spike_probability * 0.5  # Subtract up to 50 points

        # BOOST: Use ATM Bias from session state to influence signal
        try:
            if 'overall_option_data' in st.session_state:
                option_data = st.session_state.get('overall_option_data', {}).get('NIFTY', {})
                atm_bias_data = option_data.get('atm_bias', {})
                atm_verdict = atm_bias_data.get('verdict', 'NEUTRAL')
                atm_score = atm_bias_data.get('score', 0)

                if atm_verdict == 'BULLISH' or atm_score > 0.3:
                    final_score += 15
                    if 'ATM Bias Bullish' not in [r for r in bullish_reasons]:
                        bullish_reasons.append(f"ATM Bias: {atm_verdict} ({atm_score:.2f})")
                elif atm_verdict == 'BEARISH' or atm_score < -0.3:
                    final_score -= 15
                    if 'ATM Bias Bearish' not in [r for r in bearish_reasons]:
                        bearish_reasons.append(f"ATM Bias: {atm_verdict} ({atm_score:.2f})")

                # Use seller bias
                seller_bias = option_data.get('seller_bias', 'NEUTRAL')
                if seller_bias == 'BULLISH':
                    final_score += 10
                    bullish_reasons.append("Sellers favor BULLISH")
                elif seller_bias == 'BEARISH':
                    final_score -= 10
                    bearish_reasons.append("Sellers favor BEARISH")
        except Exception:
            pass

        # Determine signal with LOWER thresholds for more responsiveness
        if final_score >= 35:
            signal = "STRONG BUY"
        elif final_score >= 15:
            signal = "BUY"
        elif final_score <= -35:
            signal = "STRONG SELL"
        elif final_score <= -15:
            signal = "SELL"
        else:
            signal = "HOLD"

        # OVERRIDE: High probability spike forces signal even in "HOLD" range
        if spike_detected and spike_probability > 60 and signal == "HOLD":
            if spike_direction == 'UP':
                signal = "BUY"
                bullish_reasons.append(f"âš¡ Spike Override: {spike_probability:.0f}% UP probability")
            elif spike_direction == 'DOWN':
                signal = "SELL"
                bearish_reasons.append(f"âš¡ Spike Override: {spike_probability:.0f}% DOWN probability")

        # Calculate confidence
        confidence = min(abs(final_score) + 50, 100)

        # Determine risk level based on volatility
        if scores['volatility'] >= 70:
            risk_level = "LOW"
            position_multiplier = 1.5
        elif scores['volatility'] >= 40:
            risk_level = "MEDIUM"
            position_multiplier = 1.0
        elif scores['volatility'] >= 20:
            risk_level = "HIGH"
            position_multiplier = 0.5
        else:
            risk_level = "EXTREME"
            position_multiplier = 0.25

        # Calculate entry/exit levels
        current_price = spot_price or (df['Close'].iloc[-1] if 'Close' in df.columns else df['close'].iloc[-1])
        # Handle both 'High'/'high' and 'Low'/'low' column names
        if 'ATR' in df.columns:
            atr = df['ATR'].iloc[-1]
        else:
            high_col = 'High' if 'High' in df.columns else 'high' if 'high' in df.columns else None
            low_col = 'Low' if 'Low' in df.columns else 'low' if 'low' in df.columns else None
            if high_col and low_col:
                atr = df[high_col].iloc[-1] - df[low_col].iloc[-1]
            else:
                atr = 50  # Default ATR if columns missing

        if 'BUY' in signal:
            entry_zone = (current_price - atr * 0.5, current_price)
            stop_loss = current_price - atr * 2
            targets = [
                current_price + atr * 1.5,
                current_price + atr * 3,
                current_price + atr * 5
            ]
        elif 'SELL' in signal:
            entry_zone = (current_price, current_price + atr * 0.5)
            stop_loss = current_price + atr * 2
            targets = [
                current_price - atr * 1.5,
                current_price - atr * 3,
                current_price - atr * 5
            ]
        else:
            entry_zone = (current_price - atr, current_price + atr)
            stop_loss = 0
            targets = []

        # Get expiry data from session state if available
        expiry_data = {}
        days_to_expiry = 7.0
        expiry_spike_prob = 0.0
        expiry_spike_type = "None"
        expiry_warning = "Normal"

        try:
            if 'expiry_spike_data' in st.session_state:
                expiry_data = st.session_state.expiry_spike_data
                # Ensure expiry_data is a dict before calling .get()
                if expiry_data and isinstance(expiry_data, dict):
                    days_to_expiry = expiry_data.get('days_to_expiry', 7.0)
                    expiry_spike_prob = expiry_data.get('probability', 0.0)
                    expiry_spike_type = expiry_data.get('type', 'None')

                if expiry_spike_prob > 60:
                    expiry_warning = f"âš ï¸ HIGH RISK ({expiry_spike_prob:.0f}%)"
                    bearish_reasons.append(f"Expiry spike risk: {expiry_spike_prob:.0f}%")
                elif expiry_spike_prob > 40:
                    expiry_warning = f"MODERATE ({expiry_spike_prob:.0f}%)"
                elif days_to_expiry <= 2:
                    expiry_warning = f"EXPIRY DAY ({days_to_expiry:.1f}d)"
        except:
            pass

        # Expiry score (higher = riskier)
        scores['expiry'] = min(expiry_spike_prob, 100)

        # Get ATM option LTP from session state
        atm_strike_val = 0.0
        atm_call_ltp = 0.0
        atm_put_ltp = 0.0
        try:
            if 'merged_df' in st.session_state and st.session_state.merged_df is not None:
                merged_df = st.session_state.merged_df
                if 'atm_strike' in st.session_state:
                    atm_strike_val = st.session_state.atm_strike
                elif spot_price:
                    # Calculate ATM strike from spot price
                    if 'strikePrice' in merged_df.columns:
                        atm_strike_val = min(merged_df['strikePrice'].tolist(), key=lambda x: abs(x - spot_price))

                if atm_strike_val > 0:
                    atm_row = merged_df[merged_df['strikePrice'] == atm_strike_val]
                    if not atm_row.empty:
                        atm_call_ltp = float(atm_row['LTP_CE'].iloc[0]) if 'LTP_CE' in atm_row.columns else 0.0
                        atm_put_ltp = float(atm_row['LTP_PE'].iloc[0]) if 'LTP_PE' in atm_row.columns else 0.0
        except Exception as e:
            logger.debug(f"Could not fetch ATM LTP: {e}")

        return UnifiedSignal(
            signal=signal,
            confidence=confidence,
            regime_score=scores['regime'],
            xgboost_score=scores['xgboost'],
            volatility_score=scores['volatility'],
            oi_trap_score=scores['oi_trap'],
            cvd_score=scores['cvd'],
            liquidity_score=scores['liquidity'],
            expiry_score=scores['expiry'],
            regime=regime_name,
            volatility_state=volatility_state,
            trap_warning=trap_warning,
            recommended_strategy=strategy,
            days_to_expiry=days_to_expiry,
            expiry_spike_probability=expiry_spike_prob,
            expiry_spike_type=expiry_spike_type,
            expiry_warning=expiry_warning,
            risk_level=risk_level,
            position_size_multiplier=position_multiplier,
            entry_zone=entry_zone,
            stop_loss=stop_loss,
            targets=targets,
            bullish_reasons=bullish_reasons,
            bearish_reasons=bearish_reasons,
            atm_strike=atm_strike_val,
            atm_call_ltp=atm_call_ltp,
            atm_put_ltp=atm_put_ltp,
            timestamp=datetime.now()
        )


def render_unified_signal(signal: UnifiedSignal, spot_price: float = None):
    """
    Render the unified signal in Streamlit
    """
    # Fallback for spot_price if not provided
    if not spot_price or spot_price <= 0:
        # Try computed spot price first (set by generate_signal)
        spot_price = st.session_state.get('computed_spot_price')
    if not spot_price or spot_price <= 0:
        # Try session state
        spot_price = st.session_state.get('nifty_spot') or st.session_state.get('spot_price')
    if not spot_price or spot_price <= 0:
        # Use ATM strike as approximation
        spot_price = signal.atm_strike if signal.atm_strike and signal.atm_strike > 0 else 0
    if not spot_price or spot_price <= 0:
        # Try to get from entry zone
        if signal.entry_zone and signal.entry_zone[0] > 0:
            spot_price = (signal.entry_zone[0] + signal.entry_zone[1]) / 2
    if not spot_price or spot_price <= 0:
        # Last resort - use stop loss as reference
        if signal.stop_loss and signal.stop_loss > 0:
            spot_price = signal.stop_loss + 100  # Approximate

    # Signal color
    signal_colors = {
        'STRONG BUY': '#00FF00',
        'BUY': '#90EE90',
        'HOLD': '#FFD700',
        'SELL': '#FFA500',
        'STRONG SELL': '#FF0000'
    }
    color = signal_colors.get(signal.signal, '#808080')

    # Main signal box
    st.markdown(f"""
    <div style="background: linear-gradient(135deg, {color}22, {color}44);
                border: 3px solid {color};
                border-radius: 15px;
                padding: 25px;
                text-align: center;
                margin-bottom: 20px;">
        <h1 style="color: {color}; margin: 0; font-size: 2.5rem;">ğŸ¯ {signal.signal}</h1>
        <p style="color: #AAA; margin: 10px 0 0 0; font-size: 1.2rem;">
            Confidence: {signal.confidence:.0f}% | Risk: {signal.risk_level}
        </p>
    </div>
    """, unsafe_allow_html=True)

    # Show Spike Detector Status
    spike_data = st.session_state.get('all_day_spike_result', {})
    if spike_data:
        primary_spike = spike_data.get('primary_spike', {})
        spike_prob = primary_spike.get('probability', 0)
        spike_type = primary_spike.get('type', 'None').replace('_', ' ').title()
        spike_dir = primary_spike.get('direction', 'NEUTRAL')
        active_count = spike_data.get('active_spike_count', 0)

        if spike_prob > 0:
            spike_color = "#00ff00" if spike_dir == "UP" else "#ff4444" if spike_dir == "DOWN" else "#ffaa00"
            spike_emoji = "ğŸš€" if spike_dir == "UP" else "ğŸ“‰" if spike_dir == "DOWN" else "â†”ï¸"

            st.markdown(f"""
            <div style="background: linear-gradient(135deg, {spike_color}15, {spike_color}30);
                        border: 1px solid {spike_color};
                        border-radius: 8px;
                        padding: 10px 15px;
                        margin-bottom: 15px;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <span style="color: {spike_color}; font-weight: 700;">{spike_emoji} SPIKE: {spike_type}</span>
                        <span style="color: #888; margin-left: 10px;">({active_count} active)</span>
                    </div>
                    <div style="text-align: right;">
                        <span style="color: {spike_color}; font-size: 1.3rem; font-weight: 900;">{spike_prob:.0f}%</span>
                        <span style="color: #888; margin-left: 5px;">{spike_dir}</span>
                    </div>
                </div>
            </div>
            """, unsafe_allow_html=True)
    else:
        st.caption("ğŸ’¡ Visit NIFTY Option Screener tab to activate spike detection")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ“Š ML MARKET REGIME ASSESSMENT
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Always show regime info using signal data
    regime_data = st.session_state.get('ml_regime_result', {})

    # Use signal data as fallback
    regime = regime_data.get('regime', signal.regime) if regime_data else signal.regime
    confidence = regime_data.get('confidence', signal.confidence) if regime_data else signal.confidence
    trend_strength = regime_data.get('trend_strength', 50) if regime_data else 50
    volatility_state = regime_data.get('volatility_state', signal.volatility_state) if regime_data else signal.volatility_state
    market_phase = regime_data.get('market_phase', 'Unknown') if regime_data else 'Unknown'
    recommended_strategy = regime_data.get('recommended_strategy', signal.recommended_strategy) if regime_data else signal.recommended_strategy
    optimal_timeframe = regime_data.get('optimal_timeframe', 'Intraday') if regime_data else 'Intraday'
    signals_list = regime_data.get('signals', []) if regime_data else []
    trading_sentiment = regime_data.get('trading_sentiment', 'NEUTRAL') if regime_data else 'NEUTRAL'
    sentiment_score = regime_data.get('sentiment_score', 0) if regime_data else 0
    support_resistance = regime_data.get('support_resistance', {}) if regime_data else {}

    # Determine market phase from regime if not available
    if market_phase == 'Unknown':
        if 'Up' in regime or 'Bullish' in regime.upper() if regime else False:
            market_phase = 'Markup'
        elif 'Down' in regime or 'Bearish' in regime.upper() if regime else False:
            market_phase = 'Markdown'
        elif 'Range' in regime or 'Consolidation' in regime if regime else False:
            market_phase = 'Consolidation'
        elif 'Breakout' in regime if regime else False:
            market_phase = 'Breakout'

    # Regime color
    if regime and ('Up' in regime or 'Bullish' in str(regime).upper()):
        regime_color = "#00ff00"
        regime_emoji = "ğŸ‚"
    elif regime and ('Down' in regime or 'Bearish' in str(regime).upper()):
        regime_color = "#ff4444"
        regime_emoji = "ğŸ»"
    elif regime and 'Breakout' in regime:
        regime_color = "#ffa500"
        regime_emoji = "ğŸš€"
    else:
        regime_color = "#ffaa00"
        regime_emoji = "â†”ï¸"

    # Sentiment from spike if available
    if spike_data:
        spike_dir = spike_data.get('dominant_direction', 'NEUTRAL')
        spike_prob = spike_data.get('overall_spike_probability', 0)
        if spike_dir == 'UP' and spike_prob > 50:
            trading_sentiment = 'LONG' if spike_prob < 70 else 'STRONG LONG'
            sentiment_score = spike_prob
        elif spike_dir == 'DOWN' and spike_prob > 50:
            trading_sentiment = 'SHORT' if spike_prob < 70 else 'STRONG SHORT'
            sentiment_score = -spike_prob

    # Sentiment color
    if 'LONG' in trading_sentiment:
        sent_color = "#00ff00"
    elif 'SHORT' in trading_sentiment:
        sent_color = "#ff4444"
    else:
        sent_color = "#ffaa00"

    # Market phase explanation
    phase_explanations = {
        'Accumulation': "Smart money buying. Expect upward breakout soon.",
        'Markup': "Trending up. Follow the momentum, buy dips.",
        'Distribution': "Smart money selling. Expect downward breakdown.",
        'Markdown': "Trending down. Sell rallies, avoid longs.",
        'Consolidation': "Range-bound. Trade the range or wait for breakout.",
        'Breakout': "Breakout in progress. Follow the direction with momentum.",
        'Unknown': "Market in transition. Wait for clarity."
    }
    phase_explanation = phase_explanations.get(market_phase, "Market in transition phase.")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # EXACT S/R LEVELS - NO RANGES, EXACT PRICES ONLY
    # Priority: OI Wall > Fib 0.618 > Max Pain > Swing High/Low > HTF > VWAP
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    # Priority weights for sorting (higher = more important)
    SOURCE_PRIORITY = {
        'OI-Wall': 100,      # Option Chain OI is PRIMARY
        'MaxPain': 90,       # Max Pain is very reliable
        'Fib-0.618': 85,     # Golden ratio
        'Fib-0.382': 80,     # Strong Fib level
        'Swing': 75,         # Chart swing highs/lows
        'Fib-0.5': 70,       # 50% retracement
        'HTF': 65,           # Higher timeframe
        'Spike': 60,         # From Spike Detector
        'VWAP': 55,          # Volume weighted
        'VOB': 50,           # Volume order blocks
        'Fib-0.236': 45,     # Shallow Fib
        'Fib-0.786': 45,     # Deep Fib
        'Round': 30,         # Psychological only
    }

    exact_supports = []      # List of {'price': X, 'source': 'OI-Wall', 'label': 'PUT OI Wall'}
    exact_resistances = []   # List of {'price': X, 'source': 'Fib-0.618', 'label': '61.8% Fib'}

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 1. OPTION CHAIN OI WALLS (PRIMARY SOURCE - Most Reliable)
    # Max PUT OI = Strong Support | Max CALL OI = Strong Resistance
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    put_oi_wall_added = False
    call_oi_wall_added = False

    # Source 1: overall_option_data (support/resistance structure)
    option_data = st.session_state.get('overall_option_data', {}).get('NIFTY', {})
    if option_data and spot_price and isinstance(spot_price, (int, float)):
        # OI Wall Support (Max PUT OI strike)
        supp_data = option_data.get('support', {})
        supp_strike = supp_data.get('strike') if isinstance(supp_data, dict) else None
        if supp_strike and isinstance(supp_strike, (int, float)) and not isinstance(supp_strike, bool) and supp_strike < spot_price:
            oi_val = supp_data.get('oi', 0) if isinstance(supp_data.get('oi'), (int, float)) else 0
            exact_supports.append({
                'price': float(supp_strike),
                'source': 'OI-Wall',
                'label': f"PUT OI Wall ({oi_val/100000:.1f}L)" if oi_val else "PUT OI Wall",
                'priority': SOURCE_PRIORITY['OI-Wall']
            })
            put_oi_wall_added = True

        # OI Wall Resistance (Max CALL OI strike)
        res_data = option_data.get('resistance', {})
        res_strike = res_data.get('strike') if isinstance(res_data, dict) else None
        if res_strike and isinstance(res_strike, (int, float)) and not isinstance(res_strike, bool) and res_strike > spot_price:
            oi_val = res_data.get('oi', 0) if isinstance(res_data.get('oi'), (int, float)) else 0
            exact_resistances.append({
                'price': float(res_strike),
                'source': 'OI-Wall',
                'label': f"CALL OI Wall ({oi_val/100000:.1f}L)" if oi_val else "CALL OI Wall",
                'priority': SOURCE_PRIORITY['OI-Wall']
            })
            call_oi_wall_added = True

        # Max Pain
        max_pain = option_data.get('max_pain')
        if max_pain and isinstance(max_pain, (int, float)) and not isinstance(max_pain, bool):
            if max_pain < spot_price:
                exact_supports.append({
                    'price': float(max_pain),
                    'source': 'MaxPain',
                    'label': 'Max Pain Target',
                    'priority': SOURCE_PRIORITY['MaxPain']
                })
            else:
                exact_resistances.append({
                    'price': float(max_pain),
                    'source': 'MaxPain',
                    'label': 'Max Pain Target',
                    'priority': SOURCE_PRIORITY['MaxPain']
                })

    # Source 2: nifty_screener_data.oi_pcr_metrics (max_put_strike/max_call_strike)
    nifty_screener = st.session_state.get('nifty_screener_data', {})
    oi_pcr_metrics = nifty_screener.get('oi_pcr_metrics', {}) if isinstance(nifty_screener, dict) else {}

    if oi_pcr_metrics and spot_price and isinstance(spot_price, (int, float)):
        # PUT OI Wall from oi_pcr_metrics
        if not put_oi_wall_added:
            max_put_strike = oi_pcr_metrics.get('max_put_strike')
            max_put_oi = oi_pcr_metrics.get('max_put_oi', 0)
            if max_put_strike and isinstance(max_put_strike, (int, float)) and not isinstance(max_put_strike, bool) and max_put_strike < spot_price:
                exact_supports.append({
                    'price': float(max_put_strike),
                    'source': 'OI-Wall',
                    'label': f"PUT OI Wall ({max_put_oi/100000:.1f}L)" if max_put_oi else "PUT OI Wall",
                    'priority': SOURCE_PRIORITY['OI-Wall']
                })
                put_oi_wall_added = True

        # CALL OI Wall from oi_pcr_metrics
        if not call_oi_wall_added:
            max_call_strike = oi_pcr_metrics.get('max_call_strike')
            max_call_oi = oi_pcr_metrics.get('max_call_oi', 0)
            if max_call_strike and isinstance(max_call_strike, (int, float)) and not isinstance(max_call_strike, bool) and max_call_strike > spot_price:
                exact_resistances.append({
                    'price': float(max_call_strike),
                    'source': 'OI-Wall',
                    'label': f"CALL OI Wall ({max_call_oi/100000:.1f}L)" if max_call_oi else "CALL OI Wall",
                    'priority': SOURCE_PRIORITY['OI-Wall']
                })
                call_oi_wall_added = True

    # Source 3: merged_df - Calculate from raw option chain data if still missing
    if (not put_oi_wall_added or not call_oi_wall_added) and spot_price and isinstance(spot_price, (int, float)):
        merged_df = st.session_state.get('merged_df')
        if merged_df is not None and len(merged_df) > 0:
            try:
                # Find max PUT OI strike (for support - below spot)
                if not put_oi_wall_added and 'OI_PE' in merged_df.columns and 'strikePrice' in merged_df.columns:
                    below_spot = merged_df[merged_df['strikePrice'] < spot_price].copy()
                    if len(below_spot) > 0:
                        max_put_idx = below_spot['OI_PE'].idxmax()
                        max_put_strike = float(below_spot.loc[max_put_idx, 'strikePrice'])
                        max_put_oi = float(below_spot.loc[max_put_idx, 'OI_PE'])
                        exact_supports.append({
                            'price': max_put_strike,
                            'source': 'OI-Wall',
                            'label': f"PUT OI Wall ({max_put_oi/100000:.1f}L)",
                            'priority': SOURCE_PRIORITY['OI-Wall']
                        })
                        put_oi_wall_added = True

                # Find max CALL OI strike (for resistance - above spot)
                if not call_oi_wall_added and 'OI_CE' in merged_df.columns and 'strikePrice' in merged_df.columns:
                    above_spot = merged_df[merged_df['strikePrice'] > spot_price].copy()
                    if len(above_spot) > 0:
                        max_call_idx = above_spot['OI_CE'].idxmax()
                        max_call_strike = float(above_spot.loc[max_call_idx, 'strikePrice'])
                        max_call_oi = float(above_spot.loc[max_call_idx, 'OI_CE'])
                        exact_resistances.append({
                            'price': max_call_strike,
                            'source': 'OI-Wall',
                            'label': f"CALL OI Wall ({max_call_oi/100000:.1f}L)",
                            'priority': SOURCE_PRIORITY['OI-Wall']
                        })
                        call_oi_wall_added = True
            except Exception as e:
                logger.debug(f"Error calculating OI walls from merged_df: {e}")

    # From Spike Detector OI levels
    if spike_data and spike_data.get('key_levels') and spot_price and isinstance(spot_price, (int, float)):
        key_levels = spike_data.get('key_levels', {})
        if isinstance(key_levels, dict):
            spike_supp = key_levels.get('support')
            spike_res = key_levels.get('resistance')
            if spike_supp and isinstance(spike_supp, (int, float)) and not isinstance(spike_supp, bool) and spike_supp < spot_price:
                exact_supports.append({
                    'price': float(spike_supp),
                    'source': 'Spike',
                    'label': 'Spike OI Support',
                    'priority': SOURCE_PRIORITY['Spike']
                })
            if spike_res and isinstance(spike_res, (int, float)) and not isinstance(spike_res, bool) and spike_res > spot_price:
                exact_resistances.append({
                    'price': float(spike_res),
                    'source': 'Spike',
                    'label': 'Spike OI Resistance',
                    'priority': SOURCE_PRIORITY['Spike']
                })

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 2. FIBONACCI LEVELS (Price Action Based)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    swing_high = None
    swing_low = None

    if support_resistance:
        all_res = support_resistance.get('all_resistances', [])
        all_sup = support_resistance.get('all_supports', [])

        # Filter to only valid numeric values
        valid_res = [r for r in all_res if r and isinstance(r, (int, float)) and not isinstance(r, bool)]
        valid_sup = [s for s in all_sup if s and isinstance(s, (int, float)) and not isinstance(s, bool)]

        swing_high = max(valid_res) if valid_res else None
        swing_low = min(valid_sup) if valid_sup else None

        if not swing_high:
            major_res = support_resistance.get('major_resistance') or support_resistance.get('near_resistance')
            if major_res and isinstance(major_res, (int, float)) and not isinstance(major_res, (list, bool)):
                swing_high = float(major_res)
        if not swing_low:
            major_sup = support_resistance.get('major_support') or support_resistance.get('near_support')
            if major_sup and isinstance(major_sup, (int, float)) and not isinstance(major_sup, (list, bool)):
                swing_low = float(major_sup)

    # Validate swing_high and swing_low are numeric before comparison
    if swing_high and swing_low and isinstance(swing_high, (int, float)) and isinstance(swing_low, (int, float)) and swing_high > swing_low and spot_price:
        fib_range = swing_high - swing_low
        fib_levels = {
            '0.236': (0.236, 'Fib-0.236', '23.6% Fib'),
            '0.382': (0.382, 'Fib-0.382', '38.2% Fib'),
            '0.5':   (0.5, 'Fib-0.5', '50% Fib'),
            '0.618': (0.618, 'Fib-0.618', '61.8% Fib (Golden)'),
            '0.786': (0.786, 'Fib-0.786', '78.6% Fib'),
        }

        for name, (ratio, source_key, label) in fib_levels.items():
            fib_level = swing_high - (fib_range * ratio)
            if fib_level < spot_price:
                exact_supports.append({
                    'price': round(fib_level, 2),
                    'source': source_key,
                    'label': label,
                    'priority': SOURCE_PRIORITY.get(source_key, 40)
                })
            elif fib_level > spot_price:
                exact_resistances.append({
                    'price': round(fib_level, 2),
                    'source': source_key,
                    'label': label,
                    'priority': SOURCE_PRIORITY.get(source_key, 40)
                })

        # Swing High/Low as key levels
        if swing_high > spot_price:
            exact_resistances.append({
                'price': swing_high,
                'source': 'Swing',
                'label': 'Swing High',
                'priority': SOURCE_PRIORITY['Swing']
            })
        if swing_low < spot_price:
            exact_supports.append({
                'price': swing_low,
                'source': 'Swing',
                'label': 'Swing Low',
                'priority': SOURCE_PRIORITY['Swing']
            })

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 3. HTF S/R (Higher Timeframe)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    htf_data = st.session_state.get('htf_sr_levels', {})
    if htf_data and spot_price and isinstance(spot_price, (int, float)) and isinstance(htf_data, dict):
        for tf, levels in htf_data.items():
            if isinstance(levels, dict):
                htf_supp = levels.get('support')
                htf_res = levels.get('resistance')
                if htf_supp and isinstance(htf_supp, (int, float)) and not isinstance(htf_supp, bool) and htf_supp < spot_price:
                    exact_supports.append({
                        'price': float(htf_supp),
                        'source': 'HTF',
                        'label': f'{tf} Support',
                        'priority': SOURCE_PRIORITY['HTF']
                    })
                if htf_res and isinstance(htf_res, (int, float)) and not isinstance(htf_res, bool) and htf_res > spot_price:
                    exact_resistances.append({
                        'price': float(htf_res),
                        'source': 'HTF',
                        'label': f'{tf} Resistance',
                        'priority': SOURCE_PRIORITY['HTF']
                    })

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 4. VWAP
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    vwap = st.session_state.get('vwap_level') or st.session_state.get('nifty_vwap')
    if vwap and isinstance(vwap, (int, float)) and not isinstance(vwap, bool) and spot_price and isinstance(spot_price, (int, float)):
        if vwap < spot_price:
            exact_supports.append({
                'price': float(vwap),
                'source': 'VWAP',
                'label': 'Daily VWAP',
                'priority': SOURCE_PRIORITY['VWAP']
            })
        else:
            exact_resistances.append({
                'price': float(vwap),
                'source': 'VWAP',
                'label': 'Daily VWAP',
                'priority': SOURCE_PRIORITY['VWAP']
            })

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 5. Volume Order Blocks (VOB)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    vob_data = st.session_state.get('vob_levels', {})
    if vob_data and spot_price and isinstance(spot_price, (int, float)) and isinstance(vob_data, dict):
        bullish_blocks = vob_data.get('bullish_blocks', [])
        if isinstance(bullish_blocks, list):
            for block in bullish_blocks:
                if isinstance(block, dict):
                    block_mid = block.get('mid')
                    if block_mid and isinstance(block_mid, (int, float)) and not isinstance(block_mid, bool) and block_mid < spot_price:
                        exact_supports.append({
                            'price': float(block_mid),
                            'source': 'VOB',
                            'label': 'Bullish Order Block',
                            'priority': SOURCE_PRIORITY['VOB']
                        })
        bearish_blocks = vob_data.get('bearish_blocks', [])
        if isinstance(bearish_blocks, list):
            for block in bearish_blocks:
                if isinstance(block, dict):
                    block_mid = block.get('mid')
                    if block_mid and isinstance(block_mid, (int, float)) and not isinstance(block_mid, bool) and block_mid > spot_price:
                        exact_resistances.append({
                            'price': float(block_mid),
                            'source': 'VOB',
                            'label': 'Bearish Order Block',
                            'priority': SOURCE_PRIORITY['VOB']
                        })

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 6. Round Numbers (Psychological - lowest priority)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if spot_price and isinstance(spot_price, (int, float)):
        base = int(spot_price / 100) * 100
        for lvl in [base - 100, base, base + 100, base + 200]:
            if lvl < spot_price:
                exact_supports.append({
                    'price': lvl,
                    'source': 'Round',
                    'label': f'Round â‚¹{lvl:,.0f}',
                    'priority': SOURCE_PRIORITY['Round']
                })
            elif lvl > spot_price:
                exact_resistances.append({
                    'price': lvl,
                    'source': 'Round',
                    'label': f'Round â‚¹{lvl:,.0f}',
                    'priority': SOURCE_PRIORITY['Round']
                })

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # SORT BY PRIORITY (OI Wall first, then Fib, then others)
    # Remove duplicates (same price within 5 points)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    def dedupe_and_sort(levels, is_support=True):
        """Remove near-duplicates and sort by priority"""
        if not levels:
            return []

        # Sort by priority (highest first)
        sorted_levels = sorted(levels, key=lambda x: -x['priority'])

        # Remove duplicates within 5 points (keep higher priority)
        deduped = []
        for lvl in sorted_levels:
            is_dup = False
            for existing in deduped:
                if abs(lvl['price'] - existing['price']) <= 5:
                    is_dup = True
                    break
            if not is_dup:
                deduped.append(lvl)

        # For supports, sort by proximity to spot (closest first)
        # For resistances, sort by proximity to spot (closest first)
        if is_support:
            deduped = sorted(deduped, key=lambda x: -(x['price']))  # Highest support first (closest to spot)
        else:
            deduped = sorted(deduped, key=lambda x: x['price'])    # Lowest resistance first (closest to spot)

        return deduped[:5]  # Top 5 levels

    merged_supports = dedupe_and_sort(exact_supports, is_support=True)
    merged_resistances = dedupe_and_sort(exact_resistances, is_support=False)

    # FALLBACK - Always show S/R even if sources are empty
    if not merged_supports:
        if spot_price and spot_price > 0:
            base = int(spot_price / 50) * 50  # Align to 50-point strikes
            merged_supports = [
                {'price': base - 50, 'source': 'Round', 'label': f'Strike â‚¹{base-50:,.0f}', 'priority': 30},
                {'price': base - 100, 'source': 'Round', 'label': f'Strike â‚¹{base-100:,.0f}', 'priority': 30}
            ]
        elif signal.atm_strike and signal.atm_strike > 0:
            atm = signal.atm_strike
            merged_supports = [
                {'price': atm - 50, 'source': 'ATM', 'label': f'ATM-50', 'priority': 25},
                {'price': atm - 100, 'source': 'ATM', 'label': f'ATM-100', 'priority': 25}
            ]

    if not merged_resistances:
        if spot_price and spot_price > 0:
            base = int(spot_price / 50) * 50  # Align to 50-point strikes
            merged_resistances = [
                {'price': base + 50, 'source': 'Round', 'label': f'Strike â‚¹{base+50:,.0f}', 'priority': 30},
                {'price': base + 100, 'source': 'Round', 'label': f'Strike â‚¹{base+100:,.0f}', 'priority': 30}
            ]
        elif signal.atm_strike and signal.atm_strike > 0:
            atm = signal.atm_strike
            merged_resistances = [
                {'price': atm + 50, 'source': 'ATM', 'label': f'ATM+50', 'priority': 25},
                {'price': atm + 100, 'source': 'ATM', 'label': f'ATM+100', 'priority': 25}
            ]

    # Get primary S/R for display
    support = merged_supports[0]['price'] if merged_supports else 0
    resistance = merged_resistances[0]['price'] if merged_resistances else 0

    # Build signals text
    signals_text = ""
    if signals_list:
        for sig in signals_list[:4]:
            sig_color = "#00ff00" if "bull" in sig.lower() or "buy" in sig.lower() or "up" in sig.lower() else "#ff4444" if "bear" in sig.lower() or "sell" in sig.lower() or "down" in sig.lower() else "#aaa"
            signals_text += f'<span style="color: {sig_color};">â€¢ {sig}</span><br>'

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ML MARKET REGIME ASSESSMENT - Using Streamlit Components
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    st.markdown("---")
    st.subheader("ğŸ“Š ML MARKET REGIME ASSESSMENT")

    # Row 1: Regime and Confidence
    col1, col2 = st.columns(2)
    with col1:
        st.metric(label="Market Regime", value=f"{regime_emoji} {regime}")
    with col2:
        st.metric(label="Confidence", value=f"{confidence:.0f}%")

    # Row 2: Market Phase and Sentiment
    col3, col4 = st.columns(2)
    with col3:
        st.markdown(f"**Market Phase:** {market_phase}")
        st.caption(f"ğŸ’¡ {phase_explanation}")
    with col4:
        sent_emoji = "ğŸŸ¢" if "LONG" in str(trading_sentiment) else "ğŸ”´" if "SHORT" in str(trading_sentiment) else "ğŸŸ¡"
        st.markdown(f"**Trading Sentiment:** {sent_emoji} {trading_sentiment}")
        st.caption(f"Score: {sentiment_score:+.0f}")

    # Row 3: Technical Details
    col5, col6, col7 = st.columns(3)
    with col5:
        st.markdown(f"**Trend Strength:** {trend_strength:.0f}%")
    with col6:
        st.markdown(f"**Volatility:** {volatility_state}")
    with col7:
        st.markdown(f"**Timeframe:** {optimal_timeframe}")

    # Row 4: Trading Range (S/R from Option Chain + Chart)
    primary_supp = merged_supports[0]['price'] if merged_supports else 0
    primary_res = merged_resistances[0]['price'] if merged_resistances else 0
    range_size = abs(primary_res - primary_supp) if primary_supp and primary_res else 0

    if primary_supp > 0 or primary_res > 0:
        st.markdown("---")
        st.markdown("**ğŸ“Š EXACT S/R LEVELS (OI Wall = Primary)**")
        col_s, col_r, col_range = st.columns(3)
        with col_s:
            supp_label = merged_supports[0].get('label', 'Support') if merged_supports else "N/A"
            st.metric("ğŸ›¡ï¸ Support", f"â‚¹{primary_supp:,.0f}", delta=None, help=supp_label)
        with col_r:
            res_label = merged_resistances[0].get('label', 'Resistance') if merged_resistances else "N/A"
            st.metric("ğŸ§± Resistance", f"â‚¹{primary_res:,.0f}", delta=None, help=res_label)
        with col_range:
            st.metric("ğŸ“ Range", f"{range_size:,.0f} pts", delta=None)

        # Show current position in range
        if spot_price and primary_supp and primary_res and range_size > 0:
            position_pct = ((spot_price - primary_supp) / range_size) * 100
            position_pct = max(0, min(100, position_pct))  # Clamp 0-100
            if position_pct > 70:
                st.warning(f"âš ï¸ Price near RESISTANCE ({position_pct:.0f}% of range) - Watch for rejection")
            elif position_pct < 30:
                st.warning(f"âš ï¸ Price near SUPPORT ({position_pct:.0f}% of range) - Watch for bounce")
            else:
                st.info(f"ğŸ“ Price at {position_pct:.0f}% of range (Mid-zone)")

    # Recommended Strategy
    st.info(f"ğŸ“Œ **Recommended Strategy:** {recommended_strategy}")

    # Signals list
    if signals_list:
        with st.expander("ğŸ“¡ Active Signals", expanded=False):
            for sig in signals_list[:4]:
                if "bull" in sig.lower() or "buy" in sig.lower() or "up" in sig.lower():
                    st.success(f"â€¢ {sig}")
                elif "bear" in sig.lower() or "sell" in sig.lower() or "down" in sig.lower():
                    st.error(f"â€¢ {sig}")
                else:
                    st.write(f"â€¢ {sig}")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ“Š EXACT SUPPORT/RESISTANCE LEVELS - Python Components
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if merged_supports or merged_resistances:
        st.markdown("---")
        st.subheader("ğŸ“Š EXACT SUPPORT & RESISTANCE LEVELS")
        st.caption("OI Wall = Primary | Fib = Secondary | Exact prices only")

        col_s, col_r = st.columns(2)

        with col_s:
            st.markdown("**ğŸ›¡ï¸ SUPPORT LEVELS (Market won't go below)**")
            if merged_supports:
                for i, s in enumerate(merged_supports[:5]):
                    # Priority indicator: OI-Wall gets â˜…â˜…â˜…, Fib gets â˜…â˜…, others get â˜…
                    priority = s.get('priority', 30)
                    if priority >= 90:
                        stars = "â˜…â˜…â˜…"  # OI Wall / Max Pain
                    elif priority >= 70:
                        stars = "â˜…â˜…"   # Fib 0.618/0.382/Swing
                    else:
                        stars = "â˜…"    # HTF/VWAP/Round
                    label = s.get('label', 'Support')
                    st.success(f"S{i+1}: â‚¹{s['price']:,.0f} | {label} {stars}")
            else:
                st.caption("No support levels detected")

        with col_r:
            st.markdown("**ğŸ§± RESISTANCE LEVELS (Market won't go above)**")
            if merged_resistances:
                for i, r in enumerate(merged_resistances[:5]):
                    # Priority indicator
                    priority = r.get('priority', 30)
                    if priority >= 90:
                        stars = "â˜…â˜…â˜…"  # OI Wall / Max Pain
                    elif priority >= 70:
                        stars = "â˜…â˜…"   # Fib 0.618/0.382/Swing
                    else:
                        stars = "â˜…"    # HTF/VWAP/Round
                    label = r.get('label', 'Resistance')
                    st.error(f"R{i+1}: â‚¹{r['price']:,.0f} | {label} {stars}")
            else:
                st.caption("No resistance levels detected")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ¯ FINAL ASSESSMENT - Clear Directional Call
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Determine overall market direction
    is_bullish = signal.signal in ['STRONG BUY', 'BUY'] or (trading_sentiment and 'LONG' in trading_sentiment)
    is_bearish = signal.signal in ['STRONG SELL', 'SELL'] or (trading_sentiment and 'SHORT' in trading_sentiment)

    # Get key levels
    primary_support = merged_supports[0]['price'] if merged_supports else 0
    primary_resistance = merged_resistances[0]['price'] if merged_resistances else 0
    current_price = spot_price or 0

    # Calculate distances
    dist_to_support = abs(current_price - primary_support) if primary_support and current_price else 999
    dist_to_resistance = abs(primary_resistance - current_price) if primary_resistance and current_price else 999

    # Determine if near key level (within 30 points)
    near_support = dist_to_support < 30
    near_resistance = dist_to_resistance < 30

    # Build assessment
    if is_bullish:
        direction_color = "#00ff00"
        direction_emoji = "ğŸ‚"
        direction_text = "BULLISH"

        if near_resistance:
            # Bullish but near resistance - potential reversal
            assessment_text = f"âš ï¸ CAUTION: Market is BULLISH but approaching RESISTANCE at â‚¹{primary_resistance:,.0f}. Watch for reversal or breakout."
            move_text = f"If breakout above â‚¹{primary_resistance:,.0f} â†’ Next target: â‚¹{primary_resistance + 100:,.0f}"
            reversal_text = f"If rejection at â‚¹{primary_resistance:,.0f} â†’ Pullback to â‚¹{primary_support:,.0f}"
        else:
            assessment_text = f"ğŸ“ˆ Market will RISE from Support â‚¹{primary_support:,.0f} towards Resistance â‚¹{primary_resistance:,.0f}"
            move_text = f"Expected Move: â‚¹{primary_support:,.0f} â†’ â‚¹{primary_resistance:,.0f} ({primary_resistance - primary_support:,.0f} points)"
            reversal_text = f"ğŸ”„ Reversal Zone: If price falls below â‚¹{primary_support:,.0f}, trend may reverse to BEARISH"

    elif is_bearish:
        direction_color = "#ff4444"
        direction_emoji = "ğŸ»"
        direction_text = "BEARISH"

        if near_support:
            # Bearish but near support - potential reversal
            assessment_text = f"âš ï¸ CAUTION: Market is BEARISH but approaching SUPPORT at â‚¹{primary_support:,.0f}. Watch for reversal or breakdown."
            move_text = f"If breakdown below â‚¹{primary_support:,.0f} â†’ Next target: â‚¹{primary_support - 100:,.0f}"
            reversal_text = f"If bounce from â‚¹{primary_support:,.0f} â†’ Rally to â‚¹{primary_resistance:,.0f}"
        else:
            assessment_text = f"ğŸ“‰ Market will FALL from Resistance â‚¹{primary_resistance:,.0f} towards Support â‚¹{primary_support:,.0f}"
            move_text = f"Expected Move: â‚¹{primary_resistance:,.0f} â†’ â‚¹{primary_support:,.0f} ({primary_resistance - primary_support:,.0f} points)"
            reversal_text = f"ğŸ”„ Reversal Zone: If price rises above â‚¹{primary_resistance:,.0f}, trend may reverse to BULLISH"

    else:
        direction_color = "#ffaa00"
        direction_emoji = "â†”ï¸"
        direction_text = "NEUTRAL/RANGE"
        assessment_text = f"â†”ï¸ Market is RANGE-BOUND between â‚¹{primary_support:,.0f} and â‚¹{primary_resistance:,.0f}"
        move_text = f"Trade the Range: BUY near â‚¹{primary_support:,.0f} | SELL near â‚¹{primary_resistance:,.0f}"
        reversal_text = f"ğŸš€ Breakout Watch: Above â‚¹{primary_resistance:,.0f} = BULLISH | Below â‚¹{primary_support:,.0f} = BEARISH"

    if primary_support > 0 or primary_resistance > 0:
        st.markdown("---")
        st.subheader("ğŸ¯ FINAL ASSESSMENT")

        # Direction badge
        col_dir, col_badge = st.columns([3, 1])
        with col_dir:
            st.markdown(f"**Direction:** {direction_emoji} **{direction_text}**")
        with col_badge:
            if is_bullish:
                st.success(f"{direction_emoji} {direction_text}")
            elif is_bearish:
                st.error(f"{direction_emoji} {direction_text}")
            else:
                st.warning(f"{direction_emoji} {direction_text}")

        # Assessment text
        if is_bullish:
            if near_resistance:
                st.warning(assessment_text)
            else:
                st.success(assessment_text)
        elif is_bearish:
            if near_support:
                st.warning(assessment_text)
            else:
                st.error(assessment_text)
        else:
            st.info(assessment_text)

        # Move and Reversal
        st.markdown(f"**ğŸ“Š {move_text}**")
        st.caption(reversal_text)

        # Distance metrics
        col_p1, col_p2, col_p3 = st.columns(3)
        with col_p1:
            st.metric("Current Price", f"â‚¹{current_price:,.0f}")
        with col_p2:
            st.metric("To Support", f"{dist_to_support:,.0f} pts", delta=None)
        with col_p3:
            st.metric("To Resistance", f"{dist_to_resistance:,.0f} pts", delta=None)

    # Show ATM Option Recommendation based on signal
    st.markdown("---")
    if signal.signal in ['STRONG BUY', 'BUY'] and signal.atm_call_ltp > 0:
        st.subheader("ğŸ“ˆ BUY ATM CALL")
        col_atm1, col_atm2 = st.columns(2)
        with col_atm1:
            st.metric("Strike", f"â‚¹{signal.atm_strike:,.0f}")
        with col_atm2:
            st.metric("LTP", f"â‚¹{signal.atm_call_ltp:,.2f}")
        st.success(f"**RECOMMENDATION:** BUY {signal.atm_strike:.0f} CE @ â‚¹{signal.atm_call_ltp:.2f}")

    elif signal.signal in ['STRONG SELL', 'SELL'] and signal.atm_put_ltp > 0:
        st.subheader("ğŸ“‰ BUY ATM PUT")
        col_atm1, col_atm2 = st.columns(2)
        with col_atm1:
            st.metric("Strike", f"â‚¹{signal.atm_strike:,.0f}")
        with col_atm2:
            st.metric("LTP", f"â‚¹{signal.atm_put_ltp:,.2f}")
        st.error(f"**RECOMMENDATION:** BUY {signal.atm_strike:.0f} PE @ â‚¹{signal.atm_put_ltp:.2f}")

    # Send to Telegram for BUY/SELL signals (with auto-send option)
    if signal.signal in ['STRONG BUY', 'BUY', 'STRONG SELL', 'SELL']:
        tg_col1, tg_col2 = st.columns([3, 1])
        with tg_col1:
            auto_send = st.checkbox("ğŸ“± Auto-send to Telegram", value=True, key="ml_signal_auto_telegram")
        with tg_col2:
            manual_send = st.button("ğŸ“¤ Send Now", key="ml_signal_manual_telegram")

        # Auto-send or manual send
        if auto_send or manual_send:
            success, msg = send_ml_signal_telegram(signal, spot_price)
            if success:
                st.success(f"âœ… {msg}")
            elif "already sent" not in msg.lower() and "not configured" not in msg.lower():
                st.warning(f"âš ï¸ {msg}")

    # Metrics row 1
    col1, col2, col3, col4, col5, col6 = st.columns(6)

    with col1:
        st.metric("Regime", signal.regime, f"{signal.regime_score:+.0f}")

    with col2:
        st.metric("Volatility", signal.volatility_state, f"{signal.volatility_score:.0f}%")

    with col3:
        st.metric("OI Trap", signal.trap_warning[:12], f"{signal.oi_trap_score:+.0f}")

    with col4:
        st.metric("CVD", f"{signal.cvd_score:+.0f}", "Bull" if signal.cvd_score > 0 else "Bear" if signal.cvd_score < 0 else "-")

    with col5:
        st.metric("Expiry", f"{signal.days_to_expiry:.1f}d", signal.expiry_warning[:10])

    with col6:
        st.metric("Position", f"{signal.position_size_multiplier:.1f}x", signal.risk_level)

    st.divider()

    # Strategy recommendation
    st.info(f"ğŸ“Š **Strategy:** {signal.recommended_strategy}")

    # Entry/Exit levels
    if signal.signal != "HOLD" and spot_price:
        col1, col2 = st.columns(2)

        with col1:
            st.markdown("### ğŸ¯ Entry Zone")
            st.write(f"**Entry:** â‚¹{signal.entry_zone[0]:,.0f} - â‚¹{signal.entry_zone[1]:,.0f}")
            st.write(f"**Stop Loss:** â‚¹{signal.stop_loss:,.0f}")

        with col2:
            st.markdown("### ğŸ¯ Targets")
            for i, target in enumerate(signal.targets, 1):
                st.write(f"**T{i}:** â‚¹{target:,.0f}")

    # Reasons
    col1, col2 = st.columns(2)

    with col1:
        if signal.bullish_reasons:
            st.markdown("### ğŸ‚ Bullish Signals")
            for reason in signal.bullish_reasons:
                st.success(f"âœ… {reason}")

    with col2:
        if signal.bearish_reasons:
            st.markdown("### ğŸ» Bearish Signals")
            for reason in signal.bearish_reasons:
                st.error(f"âš ï¸ {reason}")

    # Component scores chart
    with st.expander("ğŸ“Š Component Scores Breakdown"):
        scores_df = pd.DataFrame({
            'Component': ['Regime', 'XGBoost', 'Volatility', 'OI Trap', 'CVD', 'Liquidity'],
            'Score': [
                signal.regime_score,
                signal.xgboost_score,
                signal.volatility_score - 50,  # Normalize to -50 to +50
                signal.oi_trap_score,
                signal.cvd_score,
                signal.liquidity_score
            ]
        })

        import plotly.express as px
        fig = px.bar(
            scores_df,
            x='Component',
            y='Score',
            color='Score',
            color_continuous_scale=['red', 'yellow', 'green'],
            range_color=[-100, 100]
        )
        fig.update_layout(height=300)
        st.plotly_chart(fig, use_container_width=True)


def get_cached_unified_signal() -> Optional[UnifiedSignal]:
    """Get cached unified signal from session state"""
    return st.session_state.get('unified_ml_signal')
