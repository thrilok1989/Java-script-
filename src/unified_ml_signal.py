"""
Unified ML Trading Signal
==========================
Combines ALL ML modules into a SINGLE trading signal

Modules Combined:
1. ML Market Regime Detection
2. XGBoost Prediction (BUY/SELL/HOLD)
3. Volatility Regime
4. OI Trap Detection
5. CVD Delta Imbalance
6. Liquidity Gravity Analysis
7. Institutional vs Retail Detection
8. Expiry Day Killer (False Breakout Filter)

Output: Single unified trading signal with confidence score
"""

import streamlit as st
import pandas as pd
import numpy as np
import requests
from datetime import datetime
from typing import Dict, Any, Optional, Tuple
from dataclasses import dataclass
import logging

# Import Expiry Day Killer
try:
    from src.expiry_day_killer import ExpiryDayKiller, format_killer_result
except ImportError:
    try:
        from expiry_day_killer import ExpiryDayKiller, format_killer_result
    except ImportError:
        ExpiryDayKiller = None
        format_killer_result = None

# Import SL Hunt Detector
try:
    from src.sl_hunt_detector import (
        SLHuntDetector, SLHuntResult, TrapZone,
        format_sl_hunt_telegram, format_hunt_candle_telegram
    )
except ImportError:
    try:
        from sl_hunt_detector import (
            SLHuntDetector, SLHuntResult, TrapZone,
            format_sl_hunt_telegram, format_hunt_candle_telegram
        )
    except ImportError:
        SLHuntDetector = None
        SLHuntResult = None
        TrapZone = None
        format_sl_hunt_telegram = None
        format_hunt_candle_telegram = None

logger = logging.getLogger(__name__)


def send_ml_signal_telegram(signal, spot_price: float = None):
    """
    Send ML Signal to Telegram when BUY/SELL signal is generated
    """
    try:
        # Get Telegram credentials from secrets
        bot_token = st.secrets.get("TELEGRAM_BOT_TOKEN", "")
        chat_id = st.secrets.get("TELEGRAM_CHAT_ID", "")

        if not bot_token or not chat_id:
            return False, "Telegram not configured"

        # Check if we already sent this signal (avoid duplicates)
        signal_key = f"{signal.signal}_{signal.atm_strike}_{signal.timestamp.strftime('%Y%m%d%H%M')}"
        if 'last_ml_telegram_signal' in st.session_state:
            if st.session_state.last_ml_telegram_signal == signal_key:
                return False, "Signal already sent"

        # Build the message
        if signal.signal in ['STRONG BUY', 'BUY']:
            emoji = "ğŸŸ¢ğŸ“ˆ"
            option_type = "CALL"
            option_ltp = signal.atm_call_ltp
        elif signal.signal in ['STRONG SELL', 'SELL']:
            emoji = "ğŸ”´ğŸ“‰"
            option_type = "PUT"
            option_ltp = signal.atm_put_ltp
        else:
            return False, "No actionable signal"

        # Format targets
        targets_str = ""
        if signal.targets:
            for i, t in enumerate(signal.targets, 1):
                targets_str += f"T{i}: â‚¹{t:,.0f}\n"

        # Build message
        message = f"""
{emoji} *ML TRADING SIGNAL* {emoji}

ğŸ¯ *Signal:* {signal.signal}
ğŸ“Š *Confidence:* {signal.confidence:.0f}%
âš ï¸ *Risk Level:* {signal.risk_level}

ğŸ’° *Trade Setup:*
â€¢ ATM Strike: â‚¹{signal.atm_strike:,.0f}
â€¢ Option: BUY {option_type}
â€¢ LTP: â‚¹{option_ltp:,.2f}

ğŸ“ˆ *Strategy:* {signal.recommended_strategy}

ğŸ¯ *Entry Zone:* â‚¹{signal.entry_zone[0]:,.0f} - â‚¹{signal.entry_zone[1]:,.0f}
ğŸ›‘ *Stop Loss:* â‚¹{signal.stop_loss:,.0f}

ğŸ¯ *Targets:*
{targets_str}
ğŸ“Š *Market Regime:* {signal.regime}
ğŸ“‰ *Volatility:* {signal.volatility_state}
â° *Expiry:* {signal.days_to_expiry:.1f} days

âš¡ _Generated by ML Signal Engine_
"""

        # Send to Telegram
        url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
        payload = {
            "chat_id": chat_id,
            "text": message,
            "parse_mode": "Markdown",
            "disable_web_page_preview": True
        }
        response = requests.post(url, json=payload, timeout=10)

        if response.status_code == 200:
            # Store signal key to avoid duplicates
            st.session_state.last_ml_telegram_signal = signal_key
            return True, "Signal sent to Telegram!"
        else:
            return False, f"Failed: {response.status_code}"

    except Exception as e:
        logger.error(f"Telegram send error: {e}")
        return False, f"Error: {str(e)}"


def send_reversal_entry_telegram(
    spot_price: float,
    reversal_zone: dict,
    signal_type: str,  # "SUPPORT" or "RESISTANCE"
    strike_pcr: float,
    confluence_detail: str = "",
    reversal_probability: int = 0,
    exact_reversal_price: float = None,
    killer_result = None  # ExpiryKillerResult from expiry_day_killer.py
):
    """
    Send Telegram alert when price enters EXACT REVERSAL zone

    Triggers when:
    - Price enters OI Wall entry zone
    - Multiple confluence factors align (HTF + Fib + BOS + CHOCH)
    - Reversal probability >= 75%
    - Expiry Day Killer filters pass
    """
    try:
        # Get Telegram credentials
        bot_token = st.secrets.get("TELEGRAM_BOT_TOKEN", "")
        chat_id = st.secrets.get("TELEGRAM_CHAT_ID", "")

        if not bot_token or not chat_id:
            return False, "Telegram not configured"

        # Create unique signal key to avoid duplicates
        zone_price = reversal_zone.get('entry_from', 0)
        signal_key = f"REVERSAL_{signal_type}_{int(zone_price)}_{datetime.now().strftime('%Y%m%d%H%M')}"

        if 'last_reversal_telegram' in st.session_state:
            if st.session_state.last_reversal_telegram == signal_key:
                return False, "Entry signal already sent"

        # Determine trade direction
        if signal_type == "SUPPORT":
            emoji = "ğŸŸ¢ğŸ“ˆ"
            action = "BUY CALL"
            direction = "BULLISH REVERSAL"
            entry_logic = "Price at SUPPORT - Expect bounce UP"
        else:
            emoji = "ğŸ”´ğŸ“‰"
            action = "BUY PUT"
            direction = "BEARISH REVERSAL"
            entry_logic = "Price at RESISTANCE - Expect rejection DOWN"

        # Entry zone details
        entry_from = reversal_zone.get('entry_from', 0)
        entry_to = reversal_zone.get('entry_to', 0)
        strength = reversal_zone.get('strength', 'MEDIUM')
        buffer = reversal_zone.get('buffer', 'Â±20')

        # Strength indicator
        strength_emoji = "ğŸŸ¢" if strength == "STRONG" else "ğŸŸ¡" if strength == "MEDIUM" else "ğŸ”´"

        # Killer analysis section
        killer_section = ""
        if killer_result is not None:
            risk_emoji = "ğŸŸ¢" if killer_result.risk_level == "LOW" else "ğŸŸ¡" if killer_result.risk_level == "MEDIUM" else "ğŸ”´"
            killer_section = f"""
ğŸ›¡ï¸ *EXPIRY DAY KILLER ANALYSIS:*
â€¢ Safety Score: {killer_result.overall_score:.0f}/100
â€¢ Risk Level: {risk_emoji} {killer_result.risk_level}
â€¢ Volume: {killer_result.volume_ratio:.1f}x avg {'âœ…' if killer_result.volume_filter.value == 'PASSED' else 'âš ï¸'}
â€¢ Retest: {'âœ… Confirmed' if killer_result.retest_confirmed else 'â³ Pending'}
â€¢ OI Wall: {'âœ… Aligned' if killer_result.oi_wall_aligned else 'âš ï¸ Opposing'}
â€¢ Max Pain: {'âœ… Aligned' if killer_result.max_pain_aligned else 'âš ï¸ Opposing'}
"""
            if killer_result.is_expiry_day:
                killer_section += f"â€¢ âš ï¸ EXPIRY DAY - {killer_result.minutes_to_close} mins to close\n"

        # Build message
        message = f"""
ğŸ¯ *EXACT REVERSAL ENTRY SIGNAL* ğŸ¯

{emoji} *{direction}* {emoji}

ğŸ“ *Entry Zone Triggered!*
â€¢ Spot Price: â‚¹{spot_price:,.0f}
â€¢ Entry Zone: â‚¹{entry_from:,.0f} - â‚¹{entry_to:,.0f}
â€¢ Exact Reversal: â‚¹{exact_reversal_price:,.0f}

ğŸ’ª *Strength:* {strength_emoji} {strength}
ğŸ“Š *Strike PCR:* {strike_pcr}
ğŸ¯ *Reversal Probability:* {reversal_probability}%

âš¡ *Confluence Factors:*
{confluence_detail if confluence_detail else "OI Wall + PCR"}
{killer_section}
ğŸ¬ *ACTION:* {action}
ğŸ“ *Logic:* {entry_logic}

âš ï¸ *Risk Management:*
â€¢ SL: â‚¹{entry_from - 30 if signal_type == "SUPPORT" else entry_to + 30:,.0f}
â€¢ Buffer: {buffer}

â° _{datetime.now().strftime('%H:%M:%S')}_
âš¡ _Exact Reversal + Expiry Killer System_
"""

        # Send to Telegram
        url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
        payload = {
            "chat_id": chat_id,
            "text": message,
            "parse_mode": "Markdown",
            "disable_web_page_preview": True
        }
        response = requests.post(url, json=payload, timeout=10)

        if response.status_code == 200:
            st.session_state.last_reversal_telegram = signal_key
            return True, "Entry signal sent to Telegram!"
        else:
            return False, f"Failed: {response.status_code}"

    except Exception as e:
        logger.error(f"Telegram reversal entry error: {e}")
        return False, f"Error: {str(e)}"


def send_sl_hunt_telegram(result, spot_price: float):
    """
    Send SL Hunt Alert to Telegram when high probability hunt is detected

    Sends warning BEFORE the hunt happens so traders can:
    1. Avoid entering breakout trades
    2. Wait for hunt candle
    3. Trade the reversal AFTER the hunt
    """
    try:
        if format_sl_hunt_telegram is None:
            return False, "SL Hunt module not loaded"

        # Get Telegram credentials
        bot_token = st.secrets.get("TELEGRAM_BOT_TOKEN", "")
        chat_id = st.secrets.get("TELEGRAM_CHAT_ID", "")

        if not bot_token or not chat_id:
            return False, "Telegram not configured"

        # Only send if hunt is likely
        if not result.hunt_likely:
            return False, "No hunt detected"

        # Create unique signal key to avoid duplicates
        signal_key = f"SL_HUNT_{result.hunt_direction}_{int(result.hunt_probability)}_{datetime.now().strftime('%Y%m%d%H%M')}"

        if 'last_sl_hunt_telegram' in st.session_state:
            if st.session_state.last_sl_hunt_telegram == signal_key:
                return False, "Hunt alert already sent"

        # Format message
        message = format_sl_hunt_telegram(result, spot_price)

        if not message:
            return False, "No message to send"

        # Send to Telegram
        url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
        payload = {
            "chat_id": chat_id,
            "text": message,
            "parse_mode": "Markdown",
            "disable_web_page_preview": True
        }
        response = requests.post(url, json=payload, timeout=10)

        if response.status_code == 200:
            st.session_state.last_sl_hunt_telegram = signal_key
            return True, "SL Hunt alert sent to Telegram!"
        else:
            return False, f"Failed: {response.status_code}"

    except Exception as e:
        logger.error(f"Telegram SL Hunt error: {e}")
        return False, f"Error: {str(e)}"


def analyze_sl_hunt(
    spot_price: float,
    df: pd.DataFrame = None,
    oi_data: dict = None,
    vwap: float = None,
    prev_day_high: float = None,
    prev_day_low: float = None,
    support_levels: list = None,
    resistance_levels: list = None,
    auto_send: bool = True
):
    """
    Analyze for potential stop-loss hunting and optionally send Telegram alert

    This function:
    1. Runs the complete SL Hunt analysis
    2. Stores result in session state
    3. Sends Telegram alert if hunt probability is high
    4. Returns the analysis result

    Returns:
        SLHuntResult or None
    """
    if SLHuntDetector is None:
        return None

    try:
        # Initialize detector
        detector = SLHuntDetector(
            morning_hunt_start=datetime.strptime("09:15", "%H:%M").time(),
            morning_hunt_end=datetime.strptime("10:00", "%H:%M").time(),
            closing_hunt_start=datetime.strptime("14:30", "%H:%M").time(),
            closing_hunt_end=datetime.strptime("15:30", "%H:%M").time(),
            hunt_probability_threshold=65,
        )

        # Get chart DataFrame from session state if not provided
        # Priority: chart_data (from Advanced Chart) > nifty_df
        if df is None:
            df = st.session_state.get('chart_data')
            if df is None:
                df = st.session_state.get('nifty_df')

        # Get merged_df from NIFTY Option Screener (contains OI_CE, OI_PE, Chg_OI_CE, etc.)
        merged_df = st.session_state.get('merged_df')

        # Get market depth data
        market_depth = st.session_state.get('market_depth_data')

        # Get OI data from session state if not provided
        if oi_data is None:
            oi_data = {}
            try:
                nifty_screener = st.session_state.get('nifty_screener_data', {})
                oi_pcr_metrics = nifty_screener.get('oi_pcr_metrics', {}) if isinstance(nifty_screener, dict) else {}
                option_data = st.session_state.get('overall_option_data', {}).get('NIFTY', {})

                # Build OI data structure
                oi_data = {
                    'call_oi': oi_pcr_metrics.get('call_oi', {}),
                    'put_oi': oi_pcr_metrics.get('put_oi', {}),
                    'call_oi_change': oi_pcr_metrics.get('call_oi_change', {}),
                    'put_oi_change': oi_pcr_metrics.get('put_oi_change', {}),
                    'call_premium_change': oi_pcr_metrics.get('call_premium_change', {}),
                    'put_premium_change': oi_pcr_metrics.get('put_premium_change', {}),
                    'max_call_strike': oi_pcr_metrics.get('max_call_strike', 0),
                    'max_put_strike': oi_pcr_metrics.get('max_put_strike', 0),
                    'max_pain': option_data.get('max_pain', 0)
                }
            except:
                pass

        # Get support/resistance from session state if not provided
        if support_levels is None:
            support_levels = []
            try:
                regime_data = st.session_state.get('ml_regime_result', {})
                sr_data = regime_data.get('support_resistance', {})
                for s in sr_data.get('supports', []):
                    support_levels.append(float(s) if isinstance(s, (int, float)) else s.get('price', 0))
            except:
                pass

        if resistance_levels is None:
            resistance_levels = []
            try:
                regime_data = st.session_state.get('ml_regime_result', {})
                sr_data = regime_data.get('support_resistance', {})
                for r in sr_data.get('resistances', []):
                    resistance_levels.append(float(r) if isinstance(r, (int, float)) else r.get('price', 0))
            except:
                pass

        # Run analysis with all data sources
        result = detector.analyze(
            spot_price=spot_price,
            df=df,
            oi_data=oi_data,
            merged_df=merged_df,  # From NIFTY Option Screener
            market_depth=market_depth,  # From get_market_depth_dhan()
            vwap=vwap,
            prev_day_high=prev_day_high,
            prev_day_low=prev_day_low,
            support_levels=support_levels,
            resistance_levels=resistance_levels,
        )

        # Store in session state
        st.session_state['sl_hunt_result'] = result

        # Send Telegram if hunt likely and auto_send enabled
        if auto_send and result.hunt_likely and result.hunt_probability >= 70:
            success, msg = send_sl_hunt_telegram(result, spot_price)
            if success:
                st.session_state['sl_hunt_telegram_sent'] = True

        return result

    except Exception as e:
        logger.error(f"SL Hunt analysis error: {e}")
        return None


def check_and_send_reversal_entry(
    spot_price: float,
    support_levels: list,
    resistance_levels: list,
    auto_send: bool = True,
    df: pd.DataFrame = None,
    oi_data: dict = None,
    days_to_expiry: float = 7.0
):
    """
    Check if price is in any exact reversal zone and send Telegram alert
    Uses Expiry Day Killer to filter false breakouts

    Returns: List of triggered entry signals with killer analysis
    """
    triggered_entries = []

    if not spot_price or not auto_send:
        return triggered_entries

    # Initialize Expiry Day Killer if available
    killer = None
    if ExpiryDayKiller is not None:
        killer = ExpiryDayKiller(
            expiry_cutoff_minutes=90,  # Block in last 90 mins on expiry
            volume_confirmation_ratio=1.5,  # Need 1.5x avg volume
            oi_wall_distance_threshold=50,  # Don't break INTO OI wall within 50 pts
            max_pain_alignment_threshold=30  # Max pain should align within 30 pts
        )

    # Get OI data from session state if not provided
    if oi_data is None:
        oi_data = {}
        try:
            nifty_screener = st.session_state.get('nifty_screener_data', {})
            oi_pcr_metrics = nifty_screener.get('oi_pcr_metrics', {}) if isinstance(nifty_screener, dict) else {}
            option_data = st.session_state.get('overall_option_data', {}).get('NIFTY', {})

            oi_data = {
                'max_call_strike': oi_pcr_metrics.get('max_call_strike', 0),
                'max_put_strike': oi_pcr_metrics.get('max_put_strike', 0),
                'max_pain': option_data.get('max_pain', 0)
            }
        except:
            pass

    # Get DataFrame from session state if not provided
    if df is None:
        df = st.session_state.get('nifty_df')

    # Check support levels (price near or below support = potential LONG entry)
    for supp in support_levels:
        if supp.get('is_exact_reversal') and supp.get('entry_zone'):
            entry_zone = supp['entry_zone']
            entry_from = entry_zone.get('entry_from', 0)
            entry_to = entry_zone.get('entry_to', 0)

            # Check if spot price is within entry zone
            if entry_from <= spot_price <= entry_to:
                reversal_prob = supp.get('reversal_probability', 0)
                if reversal_prob >= 75:
                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    # EXPIRY DAY KILLER CHECK - Filter false breakouts
                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    killer_result = None
                    entry_allowed = True
                    killer_msg = ""

                    if killer is not None:
                        killer_result = killer.analyze(
                            spot_price=spot_price,
                            entry_type="SUPPORT",
                            entry_zone=entry_zone,
                            df=df,
                            oi_data=oi_data,
                            days_to_expiry=days_to_expiry
                        )
                        entry_allowed = killer_result.entry_allowed
                        killer_msg = killer_result.recommendation

                        # Store killer result in session state for display
                        st.session_state['last_killer_result'] = killer_result

                    if entry_allowed:
                        success, msg = send_reversal_entry_telegram(
                            spot_price=spot_price,
                            reversal_zone=entry_zone,
                            signal_type="SUPPORT",
                            strike_pcr=supp.get('strike_pcr', 1.0),
                            confluence_detail=supp.get('confluence_detail', ''),
                            reversal_probability=reversal_prob,
                            exact_reversal_price=supp.get('exact_reversal_price', supp['price']),
                            killer_result=killer_result
                        )
                        triggered_entries.append({
                            'type': 'SUPPORT',
                            'price': supp['price'],
                            'success': success,
                            'message': msg,
                            'killer_score': killer_result.overall_score if killer_result else 100,
                            'killer_allowed': True
                        })
                    else:
                        # Entry blocked by Expiry Day Killer
                        triggered_entries.append({
                            'type': 'SUPPORT',
                            'price': supp['price'],
                            'success': False,
                            'message': f"BLOCKED: {killer_msg}",
                            'killer_score': killer_result.overall_score if killer_result else 0,
                            'killer_allowed': False,
                            'block_reasons': killer_result.block_reasons if killer_result else []
                        })

    # Check resistance levels (price near or above resistance = potential SHORT entry)
    for res in resistance_levels:
        if res.get('is_exact_reversal') and res.get('entry_zone'):
            entry_zone = res['entry_zone']
            entry_from = entry_zone.get('entry_from', 0)
            entry_to = entry_zone.get('entry_to', 0)

            # Check if spot price is within entry zone
            if entry_from <= spot_price <= entry_to:
                reversal_prob = res.get('reversal_probability', 0)
                if reversal_prob >= 75:
                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    # EXPIRY DAY KILLER CHECK - Filter false breakouts
                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    killer_result = None
                    entry_allowed = True
                    killer_msg = ""

                    if killer is not None:
                        killer_result = killer.analyze(
                            spot_price=spot_price,
                            entry_type="RESISTANCE",
                            entry_zone=entry_zone,
                            df=df,
                            oi_data=oi_data,
                            days_to_expiry=days_to_expiry
                        )
                        entry_allowed = killer_result.entry_allowed
                        killer_msg = killer_result.recommendation

                        # Store killer result in session state for display
                        st.session_state['last_killer_result'] = killer_result

                    if entry_allowed:
                        success, msg = send_reversal_entry_telegram(
                            spot_price=spot_price,
                            reversal_zone=entry_zone,
                            signal_type="RESISTANCE",
                            strike_pcr=res.get('strike_pcr', 1.0),
                            confluence_detail=res.get('confluence_detail', ''),
                            reversal_probability=reversal_prob,
                            exact_reversal_price=res.get('exact_reversal_price', res['price']),
                            killer_result=killer_result
                        )
                        triggered_entries.append({
                            'type': 'RESISTANCE',
                            'price': res['price'],
                            'success': success,
                            'message': msg,
                            'killer_score': killer_result.overall_score if killer_result else 100,
                            'killer_allowed': True
                        })
                    else:
                        # Entry blocked by Expiry Day Killer
                        triggered_entries.append({
                            'type': 'RESISTANCE',
                            'price': res['price'],
                            'success': False,
                            'message': f"BLOCKED: {killer_msg}",
                            'killer_score': killer_result.overall_score if killer_result else 0,
                            'killer_allowed': False,
                            'block_reasons': killer_result.block_reasons if killer_result else []
                        })

    return triggered_entries


@dataclass
class UnifiedSignal:
    """Unified Trading Signal"""
    signal: str  # "STRONG BUY", "BUY", "HOLD", "SELL", "STRONG SELL"
    confidence: float  # 0-100

    # Component scores
    regime_score: float  # -100 to +100
    xgboost_score: float  # -100 to +100
    volatility_score: float  # 0 to 100
    oi_trap_score: float  # -100 to +100
    cvd_score: float  # -100 to +100
    liquidity_score: float  # -100 to +100
    expiry_score: float  # 0 to 100 (risk score)

    # Details
    regime: str
    volatility_state: str
    trap_warning: str
    recommended_strategy: str

    # Expiry analysis
    days_to_expiry: float
    expiry_spike_probability: float
    expiry_spike_type: str
    expiry_warning: str

    # Risk metrics
    risk_level: str  # "LOW", "MEDIUM", "HIGH", "EXTREME"
    position_size_multiplier: float  # 0.25 to 1.5

    # Entry/Exit levels
    entry_zone: Tuple[float, float]
    stop_loss: float
    targets: list

    # Reasoning
    bullish_reasons: list
    bearish_reasons: list

    # ATM Option LTP for trade recommendation
    atm_strike: float = 0.0
    atm_call_ltp: float = 0.0
    atm_put_ltp: float = 0.0

    timestamp: datetime = None


class UnifiedMLSignalGenerator:
    """
    Generates a unified trading signal from all ML modules
    """

    def __init__(self):
        """Initialize the signal generator"""
        self.modules_loaded = {}
        self._load_modules()

    def _load_modules(self):
        """Load all ML modules"""
        # ML Market Regime
        try:
            from src.ml_market_regime import MLMarketRegimeDetector
            self.regime_detector = MLMarketRegimeDetector()
            self.modules_loaded['regime'] = True
        except ImportError:
            self.modules_loaded['regime'] = False
            self.regime_detector = None

        # XGBoost Analyzer
        try:
            from src.xgboost_ml_analyzer import XGBoostMLAnalyzer
            self.xgboost_analyzer = XGBoostMLAnalyzer()
            self.modules_loaded['xgboost'] = True
        except ImportError:
            self.modules_loaded['xgboost'] = False
            self.xgboost_analyzer = None

        # Volatility Regime
        try:
            from src.volatility_regime import VolatilityRegimeDetector
            self.volatility_detector = VolatilityRegimeDetector()
            self.modules_loaded['volatility'] = True
        except ImportError:
            self.modules_loaded['volatility'] = False
            self.volatility_detector = None

        # OI Trap Detection
        try:
            from src.oi_trap_detection import OITrapDetector
            self.oi_trap_detector = OITrapDetector()
            self.modules_loaded['oi_trap'] = True
        except ImportError:
            self.modules_loaded['oi_trap'] = False
            self.oi_trap_detector = None

        # CVD Analyzer
        try:
            from src.cvd_delta_imbalance import CVDAnalyzer
            self.cvd_analyzer = CVDAnalyzer()
            self.modules_loaded['cvd'] = True
        except ImportError:
            self.modules_loaded['cvd'] = False
            self.cvd_analyzer = None

        # Liquidity Analyzer
        try:
            from src.liquidity_gravity import LiquidityGravityAnalyzer
            self.liquidity_analyzer = LiquidityGravityAnalyzer()
            self.modules_loaded['liquidity'] = True
        except ImportError:
            self.modules_loaded['liquidity'] = False
            self.liquidity_analyzer = None

        # Institutional Detector
        try:
            from src.institutional_retail_detector import InstitutionalRetailDetector
            self.institutional_detector = InstitutionalRetailDetector()
            self.modules_loaded['institutional'] = True
        except ImportError:
            self.modules_loaded['institutional'] = False
            self.institutional_detector = None

    def generate_signal(
        self,
        df: pd.DataFrame,
        option_chain: Optional[Dict] = None,
        vix_current: Optional[float] = None,
        spot_price: Optional[float] = None,
        bias_results: Optional[Dict] = None
    ) -> UnifiedSignal:
        """
        Generate unified trading signal from all ML modules

        Args:
            df: Price DataFrame with OHLCV
            option_chain: Option chain data
            vix_current: Current VIX value
            spot_price: Current spot price
            bias_results: Results from Bias Analysis Pro

        Returns:
            UnifiedSignal with combined analysis
        """
        # Ensure we have a valid spot_price
        if not spot_price or spot_price <= 0:
            # Try to get from DataFrame
            if df is not None and len(df) > 0:
                close_col = 'Close' if 'Close' in df.columns else 'close' if 'close' in df.columns else None
                if close_col:
                    spot_price = float(df[close_col].iloc[-1])

        # Store spot_price in session state for other components
        if spot_price and spot_price > 0:
            st.session_state['computed_spot_price'] = spot_price
            st.session_state['nifty_spot'] = spot_price

        # Initialize scores
        scores = {
            'regime': 0,
            'xgboost': 0,
            'volatility': 50,  # Neutral default
            'oi_trap': 0,
            'cvd': 0,
            'liquidity': 0,
            'institutional': 0
        }

        bullish_reasons = []
        bearish_reasons = []

        regime_name = "Unknown"
        volatility_state = "Normal"
        trap_warning = "None"
        strategy = "Wait for confirmation"

        # Ensure ATR column exists (handle both 'High'/'Low' and 'high'/'low' columns)
        if 'ATR' not in df.columns:
            df = df.copy()
            # Check for column names (could be 'High' or 'high')
            high_col = 'High' if 'High' in df.columns else 'high' if 'high' in df.columns else None
            low_col = 'Low' if 'Low' in df.columns else 'low' if 'low' in df.columns else None
            if high_col and low_col:
                df['ATR'] = df[high_col] - df[low_col]
            else:
                df['ATR'] = 50  # Default ATR if columns missing

        # 1. ML Market Regime
        regime_result = None
        if self.regime_detector:
            try:
                regime_result = self.regime_detector.detect_regime(df)
                regime_name = regime_result.regime

                # Store full regime result in session state for display
                st.session_state['ml_regime_result'] = {
                    'regime': regime_result.regime,
                    'confidence': regime_result.confidence,
                    'trend_strength': regime_result.trend_strength,
                    'volatility_state': regime_result.volatility_state,
                    'market_phase': regime_result.market_phase,
                    'recommended_strategy': regime_result.recommended_strategy,
                    'optimal_timeframe': regime_result.optimal_timeframe,
                    'signals': regime_result.signals if hasattr(regime_result, 'signals') else [],
                    'trading_sentiment': getattr(regime_result, 'trading_sentiment', 'NEUTRAL'),
                    'sentiment_confidence': getattr(regime_result, 'sentiment_confidence', 0),
                    'sentiment_score': getattr(regime_result, 'sentiment_score', 0),
                    'support_resistance': getattr(regime_result, 'support_resistance', {}),
                    'entry_exit_signals': getattr(regime_result, 'entry_exit_signals', {})
                }

                # Convert regime to score (-100 to +100)
                if 'Up' in regime_name or 'BULLISH' in regime_name.upper():
                    scores['regime'] = min(regime_result.trend_strength * 1.5, 100)
                    bullish_reasons.append(f"Regime: {regime_name} (Trend: {regime_result.trend_strength:.0f}%)")
                elif 'Down' in regime_name or 'BEARISH' in regime_name.upper():
                    scores['regime'] = -min(regime_result.trend_strength * 1.5, 100)
                    bearish_reasons.append(f"Regime: {regime_name} (Trend: {regime_result.trend_strength:.0f}%)")
                else:
                    scores['regime'] = 0

                volatility_state = regime_result.volatility_state
                strategy = regime_result.recommended_strategy

            except Exception as e:
                logger.warning(f"Regime detection failed: {e}")

        # 2. Volatility Analysis
        if self.volatility_detector and vix_current:
            try:
                vol_result = self.volatility_detector.detect(df, vix_current)

                # Volatility affects position sizing, not direction
                if hasattr(vol_result, 'regime'):
                    vol_regime = str(vol_result.regime)
                    if 'Low' in vol_regime:
                        scores['volatility'] = 80
                        bullish_reasons.append("Low volatility - Good for trending")
                    elif 'High' in vol_regime or 'Extreme' in vol_regime:
                        scores['volatility'] = 20
                        bearish_reasons.append("High volatility - Reduce position")
                    else:
                        scores['volatility'] = 50

            except Exception as e:
                logger.warning(f"Volatility detection failed: {e}")

        # 3. OI Trap Detection
        if self.oi_trap_detector and option_chain and spot_price:
            try:
                oi_result = self.oi_trap_detector.detect(option_chain, spot_price)

                if hasattr(oi_result, 'trap_detected') and oi_result.trap_detected:
                    trap_type = getattr(oi_result, 'trap_type', 'Unknown')
                    trap_warning = f"{trap_type} detected!"

                    if trap_type == 'BEAR_TRAP':
                        scores['oi_trap'] = 50  # Bullish
                        bullish_reasons.append(f"Bear trap detected - Expect reversal up")
                    elif trap_type == 'BULL_TRAP':
                        scores['oi_trap'] = -50  # Bearish
                        bearish_reasons.append(f"Bull trap detected - Expect reversal down")
                else:
                    trap_warning = "No trap"

            except Exception as e:
                logger.warning(f"OI Trap detection failed: {e}")

        # 4. CVD Analysis
        if self.cvd_analyzer:
            try:
                cvd_result = self.cvd_analyzer.analyze(df)

                if hasattr(cvd_result, 'bias'):
                    if cvd_result.bias == 'Bullish':
                        scores['cvd'] = min(getattr(cvd_result, 'strength', 50), 100)
                        bullish_reasons.append(f"CVD Bullish (Strength: {scores['cvd']:.0f}%)")
                    elif cvd_result.bias == 'Bearish':
                        scores['cvd'] = -min(getattr(cvd_result, 'strength', 50), 100)
                        bearish_reasons.append(f"CVD Bearish (Strength: {abs(scores['cvd']):.0f}%)")

            except Exception as e:
                logger.warning(f"CVD analysis failed: {e}")

        # 5. Liquidity Analysis
        if self.liquidity_analyzer and option_chain and spot_price and isinstance(spot_price, (int, float)):
            try:
                liq_result = self.liquidity_analyzer.analyze(option_chain, spot_price)

                if hasattr(liq_result, 'gravity_center'):
                    gravity = liq_result.gravity_center
                    # Validate gravity is numeric before comparison
                    if gravity and isinstance(gravity, (int, float)) and not isinstance(gravity, bool):
                        if gravity > spot_price:
                            scores['liquidity'] = 30  # Price likely to move up
                            bullish_reasons.append(f"Liquidity center above price (â‚¹{gravity:,.0f})")
                        elif gravity < spot_price:
                            scores['liquidity'] = -30  # Price likely to move down
                            bearish_reasons.append(f"Liquidity center below price (â‚¹{gravity:,.0f})")

            except Exception as e:
                logger.warning(f"Liquidity analysis failed: {e}")

        # 6. Institutional Flow
        if self.institutional_detector:
            try:
                inst_result = self.institutional_detector.detect(df)

                if hasattr(inst_result, 'dominant_participant'):
                    participant = str(inst_result.dominant_participant)
                    if 'Institutional' in participant:
                        # Follow institutional money
                        if hasattr(inst_result, 'institutional_bias'):
                            if inst_result.institutional_bias == 'Bullish':
                                scores['institutional'] = 40
                                bullish_reasons.append("Institutional buying detected")
                            elif inst_result.institutional_bias == 'Bearish':
                                scores['institutional'] = -40
                                bearish_reasons.append("Institutional selling detected")

            except Exception as e:
                logger.warning(f"Institutional detection failed: {e}")

        # 7. XGBoost Prediction (if model is trained)
        if self.xgboost_analyzer and hasattr(self.xgboost_analyzer, 'is_trained') and self.xgboost_analyzer.is_trained:
            try:
                xgb_result = self.xgboost_analyzer.predict(df, bias_results, option_chain)

                if hasattr(xgb_result, 'prediction'):
                    if xgb_result.prediction == 'BUY':
                        scores['xgboost'] = xgb_result.confidence
                        bullish_reasons.append(f"XGBoost: BUY ({xgb_result.confidence:.0f}%)")
                    elif xgb_result.prediction == 'SELL':
                        scores['xgboost'] = -xgb_result.confidence
                        bearish_reasons.append(f"XGBoost: SELL ({xgb_result.confidence:.0f}%)")

            except Exception as e:
                logger.warning(f"XGBoost prediction failed: {e}")

        # 8. ALL-DAY SPIKE DETECTION (from NIFTY Option Screener)
        # This overrides range-bound signals when high probability spikes are detected
        scores['spike'] = 0
        spike_detected = False
        spike_direction = None
        spike_probability = 0

        try:
            # Get spike data from session state (set by NIFTY Option Screener)
            if 'all_day_spike_result' in st.session_state and st.session_state.all_day_spike_result:
                spike_result = st.session_state.all_day_spike_result

                # Check for active spikes
                active_spikes = spike_result.get('active_spikes', [])
                overall_spike_prob = spike_result.get('overall_spike_probability', 0)
                dominant_direction = spike_result.get('dominant_direction', 'NEUTRAL')

                if active_spikes and overall_spike_prob > 40:
                    spike_detected = True
                    spike_probability = overall_spike_prob

                    # Get highest probability spike
                    best_spike = max(active_spikes, key=lambda x: x.get('probability', 0))
                    spike_type = best_spike.get('type', 'Unknown')
                    spike_prob = best_spike.get('probability', 0)
                    spike_dir = best_spike.get('direction', dominant_direction)

                    # Score based on direction
                    if spike_dir == 'UP' or spike_dir == 'BULLISH':
                        scores['spike'] = min(spike_prob * 1.2, 100)
                        spike_direction = 'UP'
                        bullish_reasons.append(f"ğŸš€ {spike_type} Spike: {spike_prob:.0f}% - Expect UP move")
                    elif spike_dir == 'DOWN' or spike_dir == 'BEARISH':
                        scores['spike'] = -min(spike_prob * 1.2, 100)
                        spike_direction = 'DOWN'
                        bearish_reasons.append(f"ğŸ“‰ {spike_type} Spike: {spike_prob:.0f}% - Expect DOWN move")

                    # If spike probability is very high (>70%), override regime
                    if spike_prob > 70:
                        if spike_direction == 'UP':
                            regime_name = f"SPIKE UP ({spike_prob:.0f}%)"
                            strategy = f"Buy {spike_type} - High probability UP spike"
                        else:
                            regime_name = f"SPIKE DOWN ({spike_prob:.0f}%)"
                            strategy = f"Sell {spike_type} - High probability DOWN spike"

                # Check support/resistance spikes
                support_spike = spike_result.get('support_spike', {})
                resistance_spike = spike_result.get('resistance_spike', {})

                if support_spike and support_spike.get('probability', 0) > 50:
                    supp_prob = support_spike['probability']
                    scores['spike'] += min(supp_prob * 0.5, 40)
                    bullish_reasons.append(f"ğŸ›¡ï¸ Support Spike: {supp_prob:.0f}% at â‚¹{support_spike.get('level', 0):,.0f}")

                if resistance_spike and resistance_spike.get('probability', 0) > 50:
                    res_prob = resistance_spike['probability']
                    scores['spike'] -= min(res_prob * 0.5, 40)
                    bearish_reasons.append(f"ğŸ§± Resistance Spike: {res_prob:.0f}% at â‚¹{resistance_spike.get('level', 0):,.0f}")

        except Exception as e:
            logger.warning(f"Spike detection integration failed: {e}")

        # Calculate weighted final score
        weights = {
            'regime': 0.20,      # 20% (reduced to make room for spike)
            'xgboost': 0.15,     # 15% (if trained)
            'volatility': 0.10,  # 10%
            'oi_trap': 0.15,     # 15%
            'cvd': 0.10,         # 10%
            'liquidity': 0.10,   # 10%
            'institutional': 0.05,  # 5%
            'spike': 0.15        # 15% - NEW spike detection weight
        }

        # Adjust weights if XGBoost not trained
        if not (self.xgboost_analyzer and getattr(self.xgboost_analyzer, 'is_trained', False)):
            weights['xgboost'] = 0
            weights['regime'] = 0.25
            weights['oi_trap'] = 0.20
            weights['cvd'] = 0.15
            weights['spike'] = 0.20  # Increase spike weight when XGBoost not available

        # If high probability spike detected, boost spike weight significantly
        if spike_detected and spike_probability > 60:
            weights['spike'] = 0.30  # 30% weight for strong spikes
            weights['regime'] = 0.15  # Reduce regime weight

        # Normalize weights
        total_weight = sum(weights.values())
        if total_weight > 0:
            weights = {k: v / total_weight for k, v in weights.items()}

        # Calculate final score (only use keys that exist in both scores and weights)
        final_score = sum(scores.get(k, 0) * weights.get(k, 0) for k in weights.keys())

        # BOOST: If spike is detected with high probability, amplify the signal
        if spike_detected and spike_probability > 50:
            if spike_direction == 'UP':
                final_score += spike_probability * 0.5  # Add up to 50 points
            elif spike_direction == 'DOWN':
                final_score -= spike_probability * 0.5  # Subtract up to 50 points

        # BOOST: Use ATM Bias from session state to influence signal
        try:
            if 'overall_option_data' in st.session_state:
                option_data = st.session_state.get('overall_option_data', {}).get('NIFTY', {})
                atm_bias_data = option_data.get('atm_bias', {})
                atm_verdict = atm_bias_data.get('verdict', 'NEUTRAL')
                atm_score = atm_bias_data.get('score', 0)

                if atm_verdict == 'BULLISH' or atm_score > 0.3:
                    final_score += 15
                    if 'ATM Bias Bullish' not in [r for r in bullish_reasons]:
                        bullish_reasons.append(f"ATM Bias: {atm_verdict} ({atm_score:.2f})")
                elif atm_verdict == 'BEARISH' or atm_score < -0.3:
                    final_score -= 15
                    if 'ATM Bias Bearish' not in [r for r in bearish_reasons]:
                        bearish_reasons.append(f"ATM Bias: {atm_verdict} ({atm_score:.2f})")

                # Use seller bias
                seller_bias = option_data.get('seller_bias', 'NEUTRAL')
                if seller_bias == 'BULLISH':
                    final_score += 10
                    bullish_reasons.append("Sellers favor BULLISH")
                elif seller_bias == 'BEARISH':
                    final_score -= 10
                    bearish_reasons.append("Sellers favor BEARISH")
        except Exception:
            pass

        # Determine signal with LOWER thresholds for more responsiveness
        if final_score >= 35:
            signal = "STRONG BUY"
        elif final_score >= 15:
            signal = "BUY"
        elif final_score <= -35:
            signal = "STRONG SELL"
        elif final_score <= -15:
            signal = "SELL"
        else:
            signal = "HOLD"

        # OVERRIDE: High probability spike forces signal even in "HOLD" range
        if spike_detected and spike_probability > 60 and signal == "HOLD":
            if spike_direction == 'UP':
                signal = "BUY"
                bullish_reasons.append(f"âš¡ Spike Override: {spike_probability:.0f}% UP probability")
            elif spike_direction == 'DOWN':
                signal = "SELL"
                bearish_reasons.append(f"âš¡ Spike Override: {spike_probability:.0f}% DOWN probability")

        # Calculate confidence
        confidence = min(abs(final_score) + 50, 100)

        # Determine risk level based on volatility
        if scores['volatility'] >= 70:
            risk_level = "LOW"
            position_multiplier = 1.5
        elif scores['volatility'] >= 40:
            risk_level = "MEDIUM"
            position_multiplier = 1.0
        elif scores['volatility'] >= 20:
            risk_level = "HIGH"
            position_multiplier = 0.5
        else:
            risk_level = "EXTREME"
            position_multiplier = 0.25

        # Calculate entry/exit levels
        current_price = spot_price or (df['Close'].iloc[-1] if 'Close' in df.columns else df['close'].iloc[-1])
        # Handle both 'High'/'high' and 'Low'/'low' column names
        if 'ATR' in df.columns:
            atr = df['ATR'].iloc[-1]
        else:
            high_col = 'High' if 'High' in df.columns else 'high' if 'high' in df.columns else None
            low_col = 'Low' if 'Low' in df.columns else 'low' if 'low' in df.columns else None
            if high_col and low_col:
                atr = df[high_col].iloc[-1] - df[low_col].iloc[-1]
            else:
                atr = 50  # Default ATR if columns missing

        if 'BUY' in signal:
            entry_zone = (current_price - atr * 0.5, current_price)
            stop_loss = current_price - atr * 2
            targets = [
                current_price + atr * 1.5,
                current_price + atr * 3,
                current_price + atr * 5
            ]
        elif 'SELL' in signal:
            entry_zone = (current_price, current_price + atr * 0.5)
            stop_loss = current_price + atr * 2
            targets = [
                current_price - atr * 1.5,
                current_price - atr * 3,
                current_price - atr * 5
            ]
        else:
            entry_zone = (current_price - atr, current_price + atr)
            stop_loss = 0
            targets = []

        # Get expiry data from session state if available
        expiry_data = {}
        days_to_expiry = 7.0
        expiry_spike_prob = 0.0
        expiry_spike_type = "None"
        expiry_warning = "Normal"

        try:
            if 'expiry_spike_data' in st.session_state:
                expiry_data = st.session_state.expiry_spike_data
                # Ensure expiry_data is a dict before calling .get()
                if expiry_data and isinstance(expiry_data, dict):
                    days_to_expiry = expiry_data.get('days_to_expiry', 7.0)
                    expiry_spike_prob = expiry_data.get('probability', 0.0)
                    expiry_spike_type = expiry_data.get('type', 'None')

                if expiry_spike_prob > 60:
                    expiry_warning = f"âš ï¸ HIGH RISK ({expiry_spike_prob:.0f}%)"
                    bearish_reasons.append(f"Expiry spike risk: {expiry_spike_prob:.0f}%")
                elif expiry_spike_prob > 40:
                    expiry_warning = f"MODERATE ({expiry_spike_prob:.0f}%)"
                elif days_to_expiry <= 2:
                    expiry_warning = f"EXPIRY DAY ({days_to_expiry:.1f}d)"
        except:
            pass

        # Expiry score (higher = riskier)
        scores['expiry'] = min(expiry_spike_prob, 100)

        # Get ATM option LTP from session state
        atm_strike_val = 0.0
        atm_call_ltp = 0.0
        atm_put_ltp = 0.0
        try:
            if 'merged_df' in st.session_state and st.session_state.merged_df is not None:
                merged_df = st.session_state.merged_df
                if 'atm_strike' in st.session_state:
                    atm_strike_val = st.session_state.atm_strike
                elif spot_price:
                    # Calculate ATM strike from spot price
                    if 'strikePrice' in merged_df.columns:
                        atm_strike_val = min(merged_df['strikePrice'].tolist(), key=lambda x: abs(x - spot_price))

                if atm_strike_val > 0:
                    atm_row = merged_df[merged_df['strikePrice'] == atm_strike_val]
                    if not atm_row.empty:
                        atm_call_ltp = float(atm_row['LTP_CE'].iloc[0]) if 'LTP_CE' in atm_row.columns else 0.0
                        atm_put_ltp = float(atm_row['LTP_PE'].iloc[0]) if 'LTP_PE' in atm_row.columns else 0.0
        except Exception as e:
            logger.debug(f"Could not fetch ATM LTP: {e}")

        return UnifiedSignal(
            signal=signal,
            confidence=confidence,
            regime_score=scores['regime'],
            xgboost_score=scores['xgboost'],
            volatility_score=scores['volatility'],
            oi_trap_score=scores['oi_trap'],
            cvd_score=scores['cvd'],
            liquidity_score=scores['liquidity'],
            expiry_score=scores['expiry'],
            regime=regime_name,
            volatility_state=volatility_state,
            trap_warning=trap_warning,
            recommended_strategy=strategy,
            days_to_expiry=days_to_expiry,
            expiry_spike_probability=expiry_spike_prob,
            expiry_spike_type=expiry_spike_type,
            expiry_warning=expiry_warning,
            risk_level=risk_level,
            position_size_multiplier=position_multiplier,
            entry_zone=entry_zone,
            stop_loss=stop_loss,
            targets=targets,
            bullish_reasons=bullish_reasons,
            bearish_reasons=bearish_reasons,
            atm_strike=atm_strike_val,
            atm_call_ltp=atm_call_ltp,
            atm_put_ltp=atm_put_ltp,
            timestamp=datetime.now()
        )


def render_unified_signal(signal: UnifiedSignal, spot_price: float = None):
    """
    Render the unified signal in Streamlit
    """
    # Fallback for spot_price if not provided
    if not spot_price or spot_price <= 0:
        # Try computed spot price first (set by generate_signal)
        spot_price = st.session_state.get('computed_spot_price')
    if not spot_price or spot_price <= 0:
        # Try session state
        spot_price = st.session_state.get('nifty_spot') or st.session_state.get('spot_price')
    if not spot_price or spot_price <= 0:
        # Use ATM strike as approximation
        spot_price = signal.atm_strike if signal.atm_strike and signal.atm_strike > 0 else 0
    if not spot_price or spot_price <= 0:
        # Try to get from entry zone
        if signal.entry_zone and signal.entry_zone[0] > 0:
            spot_price = (signal.entry_zone[0] + signal.entry_zone[1]) / 2
    if not spot_price or spot_price <= 0:
        # Last resort - use stop loss as reference
        if signal.stop_loss and signal.stop_loss > 0:
            spot_price = signal.stop_loss + 100  # Approximate

    # Signal color
    signal_colors = {
        'STRONG BUY': '#00FF00',
        'BUY': '#90EE90',
        'HOLD': '#FFD700',
        'SELL': '#FFA500',
        'STRONG SELL': '#FF0000'
    }
    color = signal_colors.get(signal.signal, '#808080')

    # Main signal box
    st.markdown(f"""
    <div style="background: linear-gradient(135deg, {color}22, {color}44);
                border: 3px solid {color};
                border-radius: 15px;
                padding: 25px;
                text-align: center;
                margin-bottom: 20px;">
        <h1 style="color: {color}; margin: 0; font-size: 2.5rem;">ğŸ¯ {signal.signal}</h1>
        <p style="color: #AAA; margin: 10px 0 0 0; font-size: 1.2rem;">
            Confidence: {signal.confidence:.0f}% | Risk: {signal.risk_level}
        </p>
    </div>
    """, unsafe_allow_html=True)

    # Show Spike Detector Status
    spike_data = st.session_state.get('all_day_spike_result', {})
    if spike_data:
        primary_spike = spike_data.get('primary_spike', {})
        spike_prob = primary_spike.get('probability', 0)
        spike_type = primary_spike.get('type', 'None').replace('_', ' ').title()
        spike_dir = primary_spike.get('direction', 'NEUTRAL')
        active_count = spike_data.get('active_spike_count', 0)

        if spike_prob > 0:
            spike_color = "#00ff00" if spike_dir == "UP" else "#ff4444" if spike_dir == "DOWN" else "#ffaa00"
            spike_emoji = "ğŸš€" if spike_dir == "UP" else "ğŸ“‰" if spike_dir == "DOWN" else "â†”ï¸"

            st.markdown(f"""
            <div style="background: linear-gradient(135deg, {spike_color}15, {spike_color}30);
                        border: 1px solid {spike_color};
                        border-radius: 8px;
                        padding: 10px 15px;
                        margin-bottom: 15px;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <span style="color: {spike_color}; font-weight: 700;">{spike_emoji} SPIKE: {spike_type}</span>
                        <span style="color: #888; margin-left: 10px;">({active_count} active)</span>
                    </div>
                    <div style="text-align: right;">
                        <span style="color: {spike_color}; font-size: 1.3rem; font-weight: 900;">{spike_prob:.0f}%</span>
                        <span style="color: #888; margin-left: 5px;">{spike_dir}</span>
                    </div>
                </div>
            </div>
            """, unsafe_allow_html=True)
    else:
        st.caption("ğŸ’¡ Visit NIFTY Option Screener tab to activate spike detection")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ¯ STOP-LOSS HUNT DETECTOR
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    sl_hunt_result = st.session_state.get('sl_hunt_result')
    if sl_hunt_result and SLHuntResult is not None:
        hunt_prob = sl_hunt_result.hunt_probability
        hunt_likely = sl_hunt_result.hunt_likely
        hunt_dir = sl_hunt_result.hunt_direction

        # Color based on hunt probability
        if hunt_prob >= 80:
            hunt_color = "#ff0000"  # Red - HIGH RISK
            hunt_emoji = "ğŸš¨"
        elif hunt_prob >= 65:
            hunt_color = "#ff8800"  # Orange - MODERATE RISK
            hunt_emoji = "âš ï¸"
        elif hunt_prob >= 40:
            hunt_color = "#ffcc00"  # Yellow - LOW RISK
            hunt_emoji = "ğŸ””"
        else:
            hunt_color = "#00cc00"  # Green - SAFE
            hunt_emoji = "âœ…"

        # Direction indicator
        dir_emoji = "â¬†ï¸" if hunt_dir == "UP" else "â¬‡ï¸" if hunt_dir == "DOWN" else "â†”ï¸"

        st.markdown(f"""
        <div style="background: linear-gradient(135deg, {hunt_color}15, {hunt_color}30);
                    border: 2px solid {hunt_color};
                    border-radius: 10px;
                    padding: 12px 18px;
                    margin-bottom: 15px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <span style="color: {hunt_color}; font-weight: 800; font-size: 1.1rem;">
                        {hunt_emoji} SL HUNT DETECTOR
                    </span>
                    <span style="color: #aaa; margin-left: 10px;">
                        {dir_emoji} {hunt_dir}
                    </span>
                </div>
                <div style="text-align: right;">
                    <span style="color: {hunt_color}; font-size: 1.4rem; font-weight: 900;">
                        {hunt_prob:.0f}%
                    </span>
                </div>
            </div>
            <div style="margin-top: 8px; font-size: 0.85rem; color: #bbb;">
                <span style="margin-right: 10px;">ğŸ“Š OI: {sl_hunt_result.oi_absorption_score:.0f}%</span>
                <span style="margin-right: 10px;">ğŸ“‰ Depth: {sl_hunt_result.depth_spoof_score:.0f}%</span>
                <span style="margin-right: 10px;">âš¡ Effort: {sl_hunt_result.effort_result_score:.0f}%</span>
                <span style="margin-right: 10px;">ğŸ¯ SL: {sl_hunt_result.sl_cluster_score:.0f}%</span>
                <span>â° Time: {sl_hunt_result.time_risk_score:.0f}%</span>
            </div>
            <div style="margin-top: 5px; font-size: 0.9rem; color: {hunt_color}; font-weight: 600;">
                {sl_hunt_result.action}: {sl_hunt_result.reason[:80]}{'...' if len(sl_hunt_result.reason) > 80 else ''}
            </div>
        </div>
        """, unsafe_allow_html=True)

        # Show trap zones if hunt is likely
        if hunt_likely and sl_hunt_result.trap_zones:
            with st.expander("ğŸ¯ View Trap Zones & Post-Hunt Setup", expanded=False):
                # Trap zones
                st.markdown("**Top SL Trap Zones:**")
                for i, zone in enumerate(sl_hunt_result.trap_zones[:5], 1):
                    zone_emoji = "ğŸ”´" if zone.zone_type == "PUT_SL_ZONE" else "ğŸŸ¢"
                    st.markdown(f"  {i}. {zone_emoji} **â‚¹{zone.price:,.0f}** - {zone.zone_type.replace('_', ' ')} ({zone.sl_density:.0f}% density)")
                    st.caption(f"     {zone.reason}")

                # Post-hunt entry setup
                if sl_hunt_result.post_hunt_entry:
                    entry = sl_hunt_result.post_hunt_entry
                    st.markdown("---")
                    st.markdown("**ğŸ“ˆ Post-Hunt Trade Setup:**")
                    st.markdown(f"- **Direction:** {entry.get('direction', 'WAIT')}")
                    st.markdown(f"- **Wait For:** {entry.get('wait_for', 'Hunt completion')}")
                    st.markdown(f"- **Entry Trigger:** {entry.get('entry_trigger', 'Confirmation candle')}")
                    st.markdown(f"- **Stop Loss:** {entry.get('sl', 'Hunt candle extreme')}")
                    st.markdown(f"- **Target:** {entry.get('target', 'Opposite OI wall')}")
    else:
        # Run SL Hunt analysis if we have spot price
        if spot_price and spot_price > 0 and SLHuntDetector is not None:
            # Auto-analyze on first load
            if 'sl_hunt_analyzed' not in st.session_state:
                analyze_sl_hunt(spot_price, auto_send=True)
                st.session_state['sl_hunt_analyzed'] = True

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ“Š ML MARKET REGIME ASSESSMENT
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Always show regime info using signal data
    regime_data = st.session_state.get('ml_regime_result', {})

    # Use signal data as fallback
    regime = regime_data.get('regime', signal.regime) if regime_data else signal.regime
    confidence = regime_data.get('confidence', signal.confidence) if regime_data else signal.confidence
    trend_strength = regime_data.get('trend_strength', 50) if regime_data else 50
    volatility_state = regime_data.get('volatility_state', signal.volatility_state) if regime_data else signal.volatility_state
    market_phase = regime_data.get('market_phase', 'Unknown') if regime_data else 'Unknown'
    recommended_strategy = regime_data.get('recommended_strategy', signal.recommended_strategy) if regime_data else signal.recommended_strategy
    optimal_timeframe = regime_data.get('optimal_timeframe', 'Intraday') if regime_data else 'Intraday'
    signals_list = regime_data.get('signals', []) if regime_data else []
    trading_sentiment = regime_data.get('trading_sentiment', 'NEUTRAL') if regime_data else 'NEUTRAL'
    sentiment_score = regime_data.get('sentiment_score', 0) if regime_data else 0
    support_resistance = regime_data.get('support_resistance', {}) if regime_data else {}

    # Determine market phase from regime if not available
    if market_phase == 'Unknown':
        if 'Up' in regime or 'Bullish' in regime.upper() if regime else False:
            market_phase = 'Markup'
        elif 'Down' in regime or 'Bearish' in regime.upper() if regime else False:
            market_phase = 'Markdown'
        elif 'Range' in regime or 'Consolidation' in regime if regime else False:
            market_phase = 'Consolidation'
        elif 'Breakout' in regime if regime else False:
            market_phase = 'Breakout'

    # Regime color
    if regime and ('Up' in regime or 'Bullish' in str(regime).upper()):
        regime_color = "#00ff00"
        regime_emoji = "ğŸ‚"
    elif regime and ('Down' in regime or 'Bearish' in str(regime).upper()):
        regime_color = "#ff4444"
        regime_emoji = "ğŸ»"
    elif regime and 'Breakout' in regime:
        regime_color = "#ffa500"
        regime_emoji = "ğŸš€"
    else:
        regime_color = "#ffaa00"
        regime_emoji = "â†”ï¸"

    # Sentiment from spike if available
    if spike_data:
        spike_dir = spike_data.get('dominant_direction', 'NEUTRAL')
        spike_prob = spike_data.get('overall_spike_probability', 0)
        if spike_dir == 'UP' and spike_prob > 50:
            trading_sentiment = 'LONG' if spike_prob < 70 else 'STRONG LONG'
            sentiment_score = spike_prob
        elif spike_dir == 'DOWN' and spike_prob > 50:
            trading_sentiment = 'SHORT' if spike_prob < 70 else 'STRONG SHORT'
            sentiment_score = -spike_prob

    # Sentiment color
    if 'LONG' in trading_sentiment:
        sent_color = "#00ff00"
    elif 'SHORT' in trading_sentiment:
        sent_color = "#ff4444"
    else:
        sent_color = "#ffaa00"

    # Market phase explanation
    phase_explanations = {
        'Accumulation': "Smart money buying. Expect upward breakout soon.",
        'Markup': "Trending up. Follow the momentum, buy dips.",
        'Distribution': "Smart money selling. Expect downward breakdown.",
        'Markdown': "Trending down. Sell rallies, avoid longs.",
        'Consolidation': "Range-bound. Trade the range or wait for breakout.",
        'Breakout': "Breakout in progress. Follow the direction with momentum.",
        'Unknown': "Market in transition. Wait for clarity."
    }
    phase_explanation = phase_explanations.get(market_phase, "Market in transition phase.")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # EXACT S/R LEVELS - NO RANGES, EXACT PRICES ONLY
    # Priority: OI Wall > Fib 0.618 > Max Pain > Swing High/Low > HTF > VWAP
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    # Priority weights for sorting (higher = more important)
    SOURCE_PRIORITY = {
        'OI-Wall': 100,      # Option Chain OI is PRIMARY
        'MaxPain': 90,       # Max Pain is very reliable
        'Fib-0.618': 85,     # Golden ratio
        'Fib-0.382': 80,     # Strong Fib level
        'Swing': 75,         # Chart swing highs/lows
        'Fib-0.5': 70,       # 50% retracement
        'HTF': 65,           # Higher timeframe
        'Spike': 60,         # From Spike Detector
        'VWAP': 55,          # Volume weighted
        'VOB': 50,           # Volume order blocks
        'Fib-0.236': 45,     # Shallow Fib
        'Fib-0.786': 45,     # Deep Fib
        'Round': 30,         # Psychological only
    }

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # STRIKE PCR-BASED DYNAMIC S/R WIDTH CALCULATION
    # PCR at Strike = PUT OI / CALL OI at that specific strike
    # Higher PCR at support = Stronger support = Entry zone above strike
    # Lower PCR at resistance = Stronger resistance = Entry zone below strike
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    def get_strike_pcr(strike_price: float, df) -> float:
        """Calculate PCR at a specific strike from merged_df"""
        if df is None or len(df) == 0:
            return 1.0
        try:
            strike_row = df[df['strikePrice'] == strike_price]
            if len(strike_row) > 0:
                put_oi = float(strike_row['OI_PE'].iloc[0]) if 'OI_PE' in strike_row.columns else 0
                call_oi = float(strike_row['OI_CE'].iloc[0]) if 'OI_CE' in strike_row.columns else 0
                if call_oi > 0:
                    return round(put_oi / call_oi, 2)
        except Exception:
            pass
        return 1.0

    def get_support_entry_zone(strike_price: float, strike_pcr: float) -> dict:
        """
        Calculate dynamic support entry zone based on strike PCR.
        Higher PCR = Stronger PUT wall = Entry zone above strike (reverses quickly)
        Lower PCR = Weaker support = Entry zone below strike (may dip before reversing)

        Returns: {'entry_from': X, 'entry_to': Y, 'strength': 'STRONG'/'MEDIUM'/'WEAK'}
        """
        if strike_pcr >= 3.0:
            # Very strong support - reverses at or above strike
            return {
                'entry_from': strike_price,
                'entry_to': strike_price + 20,
                'strength': 'STRONG',
                'buffer': '+20'
            }
        elif strike_pcr >= 2.0:
            # Strong support - may dip 10 points
            return {
                'entry_from': strike_price - 10,
                'entry_to': strike_price + 10,
                'strength': 'STRONG',
                'buffer': 'Â±10'
            }
        elif strike_pcr >= 1.5:
            # Medium support - may dip 15 points
            return {
                'entry_from': strike_price - 15,
                'entry_to': strike_price + 5,
                'strength': 'MEDIUM',
                'buffer': '-15/+5'
            }
        else:
            # Weak support - may dip 20+ points
            return {
                'entry_from': strike_price - 20,
                'entry_to': strike_price,
                'strength': 'WEAK',
                'buffer': '-20'
            }

    def get_resistance_entry_zone(strike_price: float, strike_pcr: float) -> dict:
        """
        Calculate dynamic resistance entry zone based on strike PCR.
        Lower PCR = Stronger CALL wall = Entry zone below strike (reverses quickly)
        Higher PCR = Weaker resistance = Entry zone above strike (may push before reversing)

        Returns: {'entry_from': X, 'entry_to': Y, 'strength': 'STRONG'/'MEDIUM'/'WEAK'}
        """
        if strike_pcr <= 0.4:
            # Very strong resistance - reverses at or below strike
            return {
                'entry_from': strike_price - 20,
                'entry_to': strike_price,
                'strength': 'STRONG',
                'buffer': '-20'
            }
        elif strike_pcr <= 0.5:
            # Strong resistance - may push 10 points
            return {
                'entry_from': strike_price - 10,
                'entry_to': strike_price + 10,
                'strength': 'STRONG',
                'buffer': 'Â±10'
            }
        elif strike_pcr <= 0.7:
            # Medium resistance - may push 15 points
            return {
                'entry_from': strike_price - 5,
                'entry_to': strike_price + 15,
                'strength': 'MEDIUM',
                'buffer': '-5/+15'
            }
        else:
            # Weak resistance - may push 20+ points
            return {
                'entry_from': strike_price,
                'entry_to': strike_price + 20,
                'strength': 'WEAK',
                'buffer': '+20'
            }

    # Get merged_df once for strike PCR calculations
    merged_df_for_pcr = st.session_state.get('merged_df')

    exact_supports = []      # List of {'price': X, 'source': 'OI-Wall', 'label': 'PUT OI Wall'}
    exact_resistances = []   # List of {'price': X, 'source': 'Fib-0.618', 'label': '61.8% Fib'}

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 1. OPTION CHAIN OI WALLS (PRIMARY SOURCE - Most Reliable)
    # Max PUT OI = Strong Support | Max CALL OI = Strong Resistance
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    put_oi_wall_added = False
    call_oi_wall_added = False

    # Source 1: overall_option_data (support/resistance structure)
    option_data = st.session_state.get('overall_option_data', {}).get('NIFTY', {})
    if option_data and spot_price and isinstance(spot_price, (int, float)):
        # OI Wall Support (Max PUT OI strike)
        supp_data = option_data.get('support', {})
        supp_strike = supp_data.get('strike') if isinstance(supp_data, dict) else None
        if supp_strike and isinstance(supp_strike, (int, float)) and not isinstance(supp_strike, bool) and supp_strike < spot_price:
            oi_val = supp_data.get('oi', 0) if isinstance(supp_data.get('oi'), (int, float)) else 0
            # Calculate strike PCR and entry zone
            strike_pcr = get_strike_pcr(float(supp_strike), merged_df_for_pcr)
            entry_zone = get_support_entry_zone(float(supp_strike), strike_pcr)
            strength_icon = "ğŸŸ¢" if entry_zone['strength'] == 'STRONG' else "ğŸŸ¡" if entry_zone['strength'] == 'MEDIUM' else "ğŸ”´"
            exact_supports.append({
                'price': float(supp_strike),
                'source': 'OI-Wall',
                'label': f"PUT OI Wall ({oi_val/100000:.1f}L) PCR:{strike_pcr} {strength_icon}" if oi_val else f"PUT OI Wall PCR:{strike_pcr} {strength_icon}",
                'priority': SOURCE_PRIORITY['OI-Wall'],
                'strike_pcr': strike_pcr,
                'entry_zone': entry_zone
            })
            put_oi_wall_added = True

        # OI Wall Resistance (Max CALL OI strike)
        res_data = option_data.get('resistance', {})
        res_strike = res_data.get('strike') if isinstance(res_data, dict) else None
        if res_strike and isinstance(res_strike, (int, float)) and not isinstance(res_strike, bool) and res_strike > spot_price:
            oi_val = res_data.get('oi', 0) if isinstance(res_data.get('oi'), (int, float)) else 0
            # Calculate strike PCR and entry zone
            strike_pcr = get_strike_pcr(float(res_strike), merged_df_for_pcr)
            entry_zone = get_resistance_entry_zone(float(res_strike), strike_pcr)
            strength_icon = "ğŸŸ¢" if entry_zone['strength'] == 'STRONG' else "ğŸŸ¡" if entry_zone['strength'] == 'MEDIUM' else "ğŸ”´"
            exact_resistances.append({
                'price': float(res_strike),
                'source': 'OI-Wall',
                'label': f"CALL OI Wall ({oi_val/100000:.1f}L) PCR:{strike_pcr} {strength_icon}" if oi_val else f"CALL OI Wall PCR:{strike_pcr} {strength_icon}",
                'priority': SOURCE_PRIORITY['OI-Wall'],
                'strike_pcr': strike_pcr,
                'entry_zone': entry_zone
            })
            call_oi_wall_added = True

        # Max Pain
        max_pain = option_data.get('max_pain')
        if max_pain and isinstance(max_pain, (int, float)) and not isinstance(max_pain, bool):
            if max_pain < spot_price:
                exact_supports.append({
                    'price': float(max_pain),
                    'source': 'MaxPain',
                    'label': 'Max Pain Target',
                    'priority': SOURCE_PRIORITY['MaxPain']
                })
            else:
                exact_resistances.append({
                    'price': float(max_pain),
                    'source': 'MaxPain',
                    'label': 'Max Pain Target',
                    'priority': SOURCE_PRIORITY['MaxPain']
                })

    # Source 2: nifty_screener_data.oi_pcr_metrics (max_put_strike/max_call_strike)
    nifty_screener = st.session_state.get('nifty_screener_data', {})
    oi_pcr_metrics = nifty_screener.get('oi_pcr_metrics', {}) if isinstance(nifty_screener, dict) else {}

    if oi_pcr_metrics and spot_price and isinstance(spot_price, (int, float)):
        # PUT OI Wall from oi_pcr_metrics
        if not put_oi_wall_added:
            max_put_strike = oi_pcr_metrics.get('max_put_strike')
            max_put_oi = oi_pcr_metrics.get('max_put_oi', 0)
            if max_put_strike and isinstance(max_put_strike, (int, float)) and not isinstance(max_put_strike, bool) and max_put_strike < spot_price:
                # Calculate strike PCR and entry zone
                strike_pcr = get_strike_pcr(float(max_put_strike), merged_df_for_pcr)
                entry_zone = get_support_entry_zone(float(max_put_strike), strike_pcr)
                strength_icon = "ğŸŸ¢" if entry_zone['strength'] == 'STRONG' else "ğŸŸ¡" if entry_zone['strength'] == 'MEDIUM' else "ğŸ”´"
                exact_supports.append({
                    'price': float(max_put_strike),
                    'source': 'OI-Wall',
                    'label': f"PUT OI Wall ({max_put_oi/100000:.1f}L) PCR:{strike_pcr} {strength_icon}" if max_put_oi else f"PUT OI Wall PCR:{strike_pcr} {strength_icon}",
                    'priority': SOURCE_PRIORITY['OI-Wall'],
                    'strike_pcr': strike_pcr,
                    'entry_zone': entry_zone
                })
                put_oi_wall_added = True

        # CALL OI Wall from oi_pcr_metrics
        if not call_oi_wall_added:
            max_call_strike = oi_pcr_metrics.get('max_call_strike')
            max_call_oi = oi_pcr_metrics.get('max_call_oi', 0)
            if max_call_strike and isinstance(max_call_strike, (int, float)) and not isinstance(max_call_strike, bool) and max_call_strike > spot_price:
                # Calculate strike PCR and entry zone
                strike_pcr = get_strike_pcr(float(max_call_strike), merged_df_for_pcr)
                entry_zone = get_resistance_entry_zone(float(max_call_strike), strike_pcr)
                strength_icon = "ğŸŸ¢" if entry_zone['strength'] == 'STRONG' else "ğŸŸ¡" if entry_zone['strength'] == 'MEDIUM' else "ğŸ”´"
                exact_resistances.append({
                    'price': float(max_call_strike),
                    'source': 'OI-Wall',
                    'label': f"CALL OI Wall ({max_call_oi/100000:.1f}L) PCR:{strike_pcr} {strength_icon}" if max_call_oi else f"CALL OI Wall PCR:{strike_pcr} {strength_icon}",
                    'priority': SOURCE_PRIORITY['OI-Wall'],
                    'strike_pcr': strike_pcr,
                    'entry_zone': entry_zone
                })
                call_oi_wall_added = True

    # Source 3: merged_df - Calculate from raw option chain data if still missing
    if (not put_oi_wall_added or not call_oi_wall_added) and spot_price and isinstance(spot_price, (int, float)):
        merged_df = st.session_state.get('merged_df')
        if merged_df is not None and len(merged_df) > 0:
            try:
                # Find max PUT OI strike (for support - below spot)
                if not put_oi_wall_added and 'OI_PE' in merged_df.columns and 'strikePrice' in merged_df.columns:
                    below_spot = merged_df[merged_df['strikePrice'] < spot_price].copy()
                    if len(below_spot) > 0:
                        max_put_idx = below_spot['OI_PE'].idxmax()
                        max_put_strike = float(below_spot.loc[max_put_idx, 'strikePrice'])
                        max_put_oi = float(below_spot.loc[max_put_idx, 'OI_PE'])
                        # Calculate strike PCR directly from merged_df row
                        max_put_call_oi = float(below_spot.loc[max_put_idx, 'OI_CE']) if 'OI_CE' in below_spot.columns else 0
                        strike_pcr = round(max_put_oi / max_put_call_oi, 2) if max_put_call_oi > 0 else 1.0
                        entry_zone = get_support_entry_zone(max_put_strike, strike_pcr)
                        strength_icon = "ğŸŸ¢" if entry_zone['strength'] == 'STRONG' else "ğŸŸ¡" if entry_zone['strength'] == 'MEDIUM' else "ğŸ”´"
                        exact_supports.append({
                            'price': max_put_strike,
                            'source': 'OI-Wall',
                            'label': f"PUT OI Wall ({max_put_oi/100000:.1f}L) PCR:{strike_pcr} {strength_icon}",
                            'priority': SOURCE_PRIORITY['OI-Wall'],
                            'strike_pcr': strike_pcr,
                            'entry_zone': entry_zone
                        })
                        put_oi_wall_added = True

                # Find max CALL OI strike (for resistance - above spot)
                if not call_oi_wall_added and 'OI_CE' in merged_df.columns and 'strikePrice' in merged_df.columns:
                    above_spot = merged_df[merged_df['strikePrice'] > spot_price].copy()
                    if len(above_spot) > 0:
                        max_call_idx = above_spot['OI_CE'].idxmax()
                        max_call_strike = float(above_spot.loc[max_call_idx, 'strikePrice'])
                        max_call_oi = float(above_spot.loc[max_call_idx, 'OI_CE'])
                        # Calculate strike PCR directly from merged_df row
                        max_call_put_oi = float(above_spot.loc[max_call_idx, 'OI_PE']) if 'OI_PE' in above_spot.columns else 0
                        strike_pcr = round(max_call_put_oi / max_call_oi, 2) if max_call_oi > 0 else 1.0
                        entry_zone = get_resistance_entry_zone(max_call_strike, strike_pcr)
                        strength_icon = "ğŸŸ¢" if entry_zone['strength'] == 'STRONG' else "ğŸŸ¡" if entry_zone['strength'] == 'MEDIUM' else "ğŸ”´"
                        exact_resistances.append({
                            'price': max_call_strike,
                            'source': 'OI-Wall',
                            'label': f"CALL OI Wall ({max_call_oi/100000:.1f}L) PCR:{strike_pcr} {strength_icon}",
                            'priority': SOURCE_PRIORITY['OI-Wall'],
                            'strike_pcr': strike_pcr,
                            'entry_zone': entry_zone
                        })
                        call_oi_wall_added = True
            except Exception as e:
                logger.debug(f"Error calculating OI walls from merged_df: {e}")

    # From Spike Detector OI levels
    if spike_data and spike_data.get('key_levels') and spot_price and isinstance(spot_price, (int, float)):
        key_levels = spike_data.get('key_levels', {})
        if isinstance(key_levels, dict):
            spike_supp = key_levels.get('support')
            spike_res = key_levels.get('resistance')
            if spike_supp and isinstance(spike_supp, (int, float)) and not isinstance(spike_supp, bool) and spike_supp < spot_price:
                exact_supports.append({
                    'price': float(spike_supp),
                    'source': 'Spike',
                    'label': 'Spike OI Support',
                    'priority': SOURCE_PRIORITY['Spike']
                })
            if spike_res and isinstance(spike_res, (int, float)) and not isinstance(spike_res, bool) and spike_res > spot_price:
                exact_resistances.append({
                    'price': float(spike_res),
                    'source': 'Spike',
                    'label': 'Spike OI Resistance',
                    'priority': SOURCE_PRIORITY['Spike']
                })

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 1.5 ADVANCED CHART ANALYSIS S/R (Reversal Zones + Price Action)
    # Uses: Swing Highs/Lows, Reversal Probability Zones, BOS/CHOCH levels
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Add priority for Advanced Chart sources
    if 'Reversal' not in SOURCE_PRIORITY:
        SOURCE_PRIORITY['Reversal'] = 82  # Between Fib 0.618 and Fib 0.382
    if 'BOS' not in SOURCE_PRIORITY:
        SOURCE_PRIORITY['BOS'] = 78  # Break of Structure
    if 'CHOCH' not in SOURCE_PRIORITY:
        SOURCE_PRIORITY['CHOCH'] = 77  # Change of Character

    # Get reversal zones data from session state (from Advanced Chart Analysis tab)
    reversal_zones_data = st.session_state.get('reversal_zones_data', {})
    price_action_data = st.session_state.get('price_action_data', {})

    if reversal_zones_data and reversal_zones_data.get('success') and spot_price:
        try:
            zone = reversal_zones_data.get('zone')
            if zone:
                # Add percentile target prices as potential reversal levels
                if zone.is_bullish:
                    # Bullish - targets are above current price (resistance)
                    if zone.percentile_50_price and zone.percentile_50_price > spot_price:
                        exact_resistances.append({
                            'price': round(zone.percentile_50_price, 2),
                            'source': 'Reversal',
                            'label': 'Reversal Target 50%',
                            'priority': SOURCE_PRIORITY['Reversal']
                        })
                    if zone.percentile_75_price and zone.percentile_75_price > spot_price:
                        exact_resistances.append({
                            'price': round(zone.percentile_75_price, 2),
                            'source': 'Reversal',
                            'label': 'Reversal Target 75%',
                            'priority': SOURCE_PRIORITY['Reversal'] - 2
                        })
                else:
                    # Bearish - targets are below current price (support)
                    if zone.percentile_50_price and zone.percentile_50_price < spot_price:
                        exact_supports.append({
                            'price': round(zone.percentile_50_price, 2),
                            'source': 'Reversal',
                            'label': 'Reversal Target 50%',
                            'priority': SOURCE_PRIORITY['Reversal']
                        })
                    if zone.percentile_75_price and zone.percentile_75_price < spot_price:
                        exact_supports.append({
                            'price': round(zone.percentile_75_price, 2),
                            'source': 'Reversal',
                            'label': 'Reversal Target 75%',
                            'priority': SOURCE_PRIORITY['Reversal'] - 2
                        })

            # Add swing highs/lows from reversal zones
            swing_highs_rz = reversal_zones_data.get('swing_highs', [])
            swing_lows_rz = reversal_zones_data.get('swing_lows', [])

            for sh in swing_highs_rz[-3:]:  # Last 3 swing highs
                sh_price = sh.get('price')
                if sh_price and isinstance(sh_price, (int, float)) and sh_price > spot_price:
                    exact_resistances.append({
                        'price': float(sh_price),
                        'source': 'HTF',
                        'label': 'Chart Swing High',
                        'priority': SOURCE_PRIORITY['HTF']
                    })

            for sl in swing_lows_rz[-3:]:  # Last 3 swing lows
                sl_price = sl.get('price')
                if sl_price and isinstance(sl_price, (int, float)) and sl_price < spot_price:
                    exact_supports.append({
                        'price': float(sl_price),
                        'source': 'HTF',
                        'label': 'Chart Swing Low',
                        'priority': SOURCE_PRIORITY['HTF']
                    })
        except Exception as e:
            logger.debug(f"Error processing reversal zones data: {e}")

    # Get BOS/CHOCH structure levels from price action data
    if price_action_data and price_action_data.get('success') and spot_price:
        try:
            # BOS (Break of Structure) levels
            bos_events = price_action_data.get('bos_events', [])
            for bos in bos_events[-5:]:  # Last 5 BOS events
                struct_level = bos.get('structure_level')
                bos_type = bos.get('type', '')
                if struct_level and isinstance(struct_level, (int, float)):
                    if bos_type == 'BULLISH' and struct_level > spot_price:
                        exact_resistances.append({
                            'price': float(struct_level),
                            'source': 'BOS',
                            'label': f'BOS Bullish â†‘',
                            'priority': SOURCE_PRIORITY['BOS']
                        })
                    elif bos_type == 'BEARISH' and struct_level < spot_price:
                        exact_supports.append({
                            'price': float(struct_level),
                            'source': 'BOS',
                            'label': f'BOS Bearish â†“',
                            'priority': SOURCE_PRIORITY['BOS']
                        })

            # CHOCH (Change of Character) levels - trend reversals
            choch_events = price_action_data.get('choch_events', [])
            for choch in choch_events[-3:]:  # Last 3 CHOCH events
                struct_level = choch.get('structure_level')
                choch_type = choch.get('type', '')
                if struct_level and isinstance(struct_level, (int, float)):
                    if struct_level > spot_price:
                        exact_resistances.append({
                            'price': float(struct_level),
                            'source': 'CHOCH',
                            'label': f'CHOCH {choch_type}',
                            'priority': SOURCE_PRIORITY['CHOCH']
                        })
                    elif struct_level < spot_price:
                        exact_supports.append({
                            'price': float(struct_level),
                            'source': 'CHOCH',
                            'label': f'CHOCH {choch_type}',
                            'priority': SOURCE_PRIORITY['CHOCH']
                        })
        except Exception as e:
            logger.debug(f"Error processing price action data: {e}")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 2. FIBONACCI LEVELS (Price Action Based)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    swing_high = None
    swing_low = None

    if support_resistance:
        all_res = support_resistance.get('all_resistances', [])
        all_sup = support_resistance.get('all_supports', [])

        # Filter to only valid numeric values
        valid_res = [r for r in all_res if r and isinstance(r, (int, float)) and not isinstance(r, bool)]
        valid_sup = [s for s in all_sup if s and isinstance(s, (int, float)) and not isinstance(s, bool)]

        swing_high = max(valid_res) if valid_res else None
        swing_low = min(valid_sup) if valid_sup else None

        if not swing_high:
            major_res = support_resistance.get('major_resistance') or support_resistance.get('near_resistance')
            if major_res and isinstance(major_res, (int, float)) and not isinstance(major_res, (list, bool)):
                swing_high = float(major_res)
        if not swing_low:
            major_sup = support_resistance.get('major_support') or support_resistance.get('near_support')
            if major_sup and isinstance(major_sup, (int, float)) and not isinstance(major_sup, (list, bool)):
                swing_low = float(major_sup)

    # Validate swing_high and swing_low are numeric before comparison
    if swing_high and swing_low and isinstance(swing_high, (int, float)) and isinstance(swing_low, (int, float)) and swing_high > swing_low and spot_price:
        fib_range = swing_high - swing_low
        fib_levels = {
            '0.236': (0.236, 'Fib-0.236', '23.6% Fib'),
            '0.382': (0.382, 'Fib-0.382', '38.2% Fib'),
            '0.5':   (0.5, 'Fib-0.5', '50% Fib'),
            '0.618': (0.618, 'Fib-0.618', '61.8% Fib (Golden)'),
            '0.786': (0.786, 'Fib-0.786', '78.6% Fib'),
        }

        for name, (ratio, source_key, label) in fib_levels.items():
            fib_level = swing_high - (fib_range * ratio)
            if fib_level < spot_price:
                exact_supports.append({
                    'price': round(fib_level, 2),
                    'source': source_key,
                    'label': label,
                    'priority': SOURCE_PRIORITY.get(source_key, 40)
                })
            elif fib_level > spot_price:
                exact_resistances.append({
                    'price': round(fib_level, 2),
                    'source': source_key,
                    'label': label,
                    'priority': SOURCE_PRIORITY.get(source_key, 40)
                })

        # Swing High/Low as key levels
        if swing_high > spot_price:
            exact_resistances.append({
                'price': swing_high,
                'source': 'Swing',
                'label': 'Swing High',
                'priority': SOURCE_PRIORITY['Swing']
            })
        if swing_low < spot_price:
            exact_supports.append({
                'price': swing_low,
                'source': 'Swing',
                'label': 'Swing Low',
                'priority': SOURCE_PRIORITY['Swing']
            })

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 3. HTF S/R (Higher Timeframe Pivot Points)
    # Calculate pivot highs/lows from different lookback periods
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    htf_data = st.session_state.get('htf_sr_levels', {})

    # If HTF data not available, calculate from DataFrame
    if not htf_data and 'nifty_df' in st.session_state:
        try:
            df_htf = st.session_state.get('nifty_df')
            if df_htf is not None and len(df_htf) > 20:
                # Normalize column names
                high_col = 'High' if 'High' in df_htf.columns else 'high'
                low_col = 'Low' if 'Low' in df_htf.columns else 'low'

                if high_col in df_htf.columns and low_col in df_htf.columns:
                    htf_data = {}

                    # Calculate pivot points for different periods (simulating HTF)
                    # 15min chart with 10 bars = ~2.5 hours of data
                    # 15min chart with 20 bars = ~5 hours of data
                    # 15min chart with 40 bars = ~10 hours (daily range)

                    periods = {
                        '5min': 2,     # 2 bars = 30 min lookback (short-term)
                        '10min': 3,    # 3 bars = 45 min lookback
                        '15min': 5,    # 5 bars = 1.25 hours lookback
                        '1H': 10,      # 10 bars = 2.5 hours lookback
                        '4H': 20,      # 20 bars = 5 hours lookback
                        'Daily': 40    # 40 bars = 10 hours lookback
                    }

                    for tf_name, lookback in periods.items():
                        if len(df_htf) > lookback * 2:
                            # Find pivot high (highest high in lookback period)
                            recent_highs = df_htf[high_col].iloc[-lookback*2:-lookback].values
                            recent_lows = df_htf[low_col].iloc[-lookback*2:-lookback].values

                            if len(recent_highs) > 0 and len(recent_lows) > 0:
                                pivot_high = float(max(recent_highs))
                                pivot_low = float(min(recent_lows))

                                htf_data[tf_name] = {
                                    'support': pivot_low,
                                    'resistance': pivot_high
                                }

                    # Store for future use
                    if htf_data:
                        st.session_state['htf_sr_levels'] = htf_data

        except Exception as e:
            logger.debug(f"HTF calculation error: {e}")

    if htf_data and spot_price and isinstance(spot_price, (int, float)) and isinstance(htf_data, dict):
        for tf, levels in htf_data.items():
            if isinstance(levels, dict):
                htf_supp = levels.get('support')
                htf_res = levels.get('resistance')
                if htf_supp and isinstance(htf_supp, (int, float)) and not isinstance(htf_supp, bool) and htf_supp < spot_price:
                    exact_supports.append({
                        'price': float(htf_supp),
                        'source': 'HTF',
                        'label': f'{tf} Pivot Low',
                        'priority': SOURCE_PRIORITY['HTF']
                    })
                if htf_res and isinstance(htf_res, (int, float)) and not isinstance(htf_res, bool) and htf_res > spot_price:
                    exact_resistances.append({
                        'price': float(htf_res),
                        'source': 'HTF',
                        'label': f'{tf} Pivot High',
                        'priority': SOURCE_PRIORITY['HTF']
                    })

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 4. VWAP
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    vwap = st.session_state.get('vwap_level') or st.session_state.get('nifty_vwap')
    if vwap and isinstance(vwap, (int, float)) and not isinstance(vwap, bool) and spot_price and isinstance(spot_price, (int, float)):
        if vwap < spot_price:
            exact_supports.append({
                'price': float(vwap),
                'source': 'VWAP',
                'label': 'Daily VWAP',
                'priority': SOURCE_PRIORITY['VWAP']
            })
        else:
            exact_resistances.append({
                'price': float(vwap),
                'source': 'VWAP',
                'label': 'Daily VWAP',
                'priority': SOURCE_PRIORITY['VWAP']
            })

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 5. Volume Order Blocks (VOB)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    vob_data = st.session_state.get('vob_levels', {})
    if vob_data and spot_price and isinstance(spot_price, (int, float)) and isinstance(vob_data, dict):
        bullish_blocks = vob_data.get('bullish_blocks', [])
        if isinstance(bullish_blocks, list):
            for block in bullish_blocks:
                if isinstance(block, dict):
                    block_mid = block.get('mid')
                    if block_mid and isinstance(block_mid, (int, float)) and not isinstance(block_mid, bool) and block_mid < spot_price:
                        exact_supports.append({
                            'price': float(block_mid),
                            'source': 'VOB',
                            'label': 'Bullish Order Block',
                            'priority': SOURCE_PRIORITY['VOB']
                        })
        bearish_blocks = vob_data.get('bearish_blocks', [])
        if isinstance(bearish_blocks, list):
            for block in bearish_blocks:
                if isinstance(block, dict):
                    block_mid = block.get('mid')
                    if block_mid and isinstance(block_mid, (int, float)) and not isinstance(block_mid, bool) and block_mid > spot_price:
                        exact_resistances.append({
                            'price': float(block_mid),
                            'source': 'VOB',
                            'label': 'Bearish Order Block',
                            'priority': SOURCE_PRIORITY['VOB']
                        })

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 6. Round Numbers (Psychological - lowest priority)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if spot_price and isinstance(spot_price, (int, float)):
        base = int(spot_price / 100) * 100
        for lvl in [base - 100, base, base + 100, base + 200]:
            if lvl < spot_price:
                exact_supports.append({
                    'price': lvl,
                    'source': 'Round',
                    'label': f'Round â‚¹{lvl:,.0f}',
                    'priority': SOURCE_PRIORITY['Round']
                })
            elif lvl > spot_price:
                exact_resistances.append({
                    'price': lvl,
                    'source': 'Round',
                    'label': f'Round â‚¹{lvl:,.0f}',
                    'priority': SOURCE_PRIORITY['Round']
                })

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 7. EXACT REVERSAL DETECTION (OI Wall Entry Zone + Fib + HTF Confluence)
    # Combines: OI Wall PCR-based entry zone + Fibonacci levels + HTF pivots
    # When multiple factors align = HIGH PROBABILITY EXACT REVERSAL POINT
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    CONFLUENCE_TOLERANCE = 20  # Points within which levels are considered aligned

    def find_exact_reversal_zones(levels, is_support=True):
        """
        Find EXACT REVERSAL zones by combining:
        1. OI Wall with PCR-based entry zone
        2. Fibonacci levels within entry zone
        3. HTF pivots (5min/10min/15min) within entry zone
        4. BOS/CHOCH structure levels within entry zone
        5. Reversal Probability Zones targets within entry zone

        Returns enhanced levels with reversal probability score
        """
        if not levels or len(levels) < 2:
            return levels

        # Separate by source type
        oi_walls = [l for l in levels if l['source'] == 'OI-Wall' and l.get('entry_zone')]
        htf_levels = [l for l in levels if l['source'] == 'HTF']
        fib_levels = [l for l in levels if 'Fib' in l['source']]
        bos_levels = [l for l in levels if l['source'] == 'BOS']
        choch_levels = [l for l in levels if l['source'] == 'CHOCH']
        reversal_levels = [l for l in levels if l['source'] == 'Reversal']
        other_levels = [l for l in levels if l['source'] not in ['OI-Wall', 'HTF', 'BOS', 'CHOCH', 'Reversal'] and 'Fib' not in l['source']]

        # For each OI Wall, find confluent levels within its entry zone
        enhanced_oi_walls = []
        used_htf = set()
        used_fib = set()
        used_bos = set()
        used_choch = set()
        used_reversal = set()

        for oi in oi_walls:
            entry_zone = oi.get('entry_zone', {})
            zone_from = entry_zone.get('entry_from', oi['price'] - 20)
            zone_to = entry_zone.get('entry_to', oi['price'] + 20)
            strike_pcr = oi.get('strike_pcr', 1.0)

            # Find HTF pivots within OI Wall entry zone
            htf_in_zone = []
            for i, htf in enumerate(htf_levels):
                if i not in used_htf and zone_from <= htf['price'] <= zone_to:
                    htf_in_zone.append(htf)
                    used_htf.add(i)

            # Find Fib levels within OI Wall entry zone
            fib_in_zone = []
            for j, fib in enumerate(fib_levels):
                if j not in used_fib and zone_from <= fib['price'] <= zone_to:
                    fib_in_zone.append(fib)
                    used_fib.add(j)

            # Find BOS levels within OI Wall entry zone
            bos_in_zone = []
            for k, bos in enumerate(bos_levels):
                if k not in used_bos and zone_from <= bos['price'] <= zone_to:
                    bos_in_zone.append(bos)
                    used_bos.add(k)

            # Find CHOCH levels within OI Wall entry zone
            choch_in_zone = []
            for m, choch in enumerate(choch_levels):
                if m not in used_choch and zone_from <= choch['price'] <= zone_to:
                    choch_in_zone.append(choch)
                    used_choch.add(m)

            # Find Reversal targets within OI Wall entry zone
            reversal_in_zone = []
            for n, rev in enumerate(reversal_levels):
                if n not in used_reversal and zone_from <= rev['price'] <= zone_to:
                    reversal_in_zone.append(rev)
                    used_reversal.add(n)

            # Calculate REVERSAL PROBABILITY based on confluence
            # Base score from PCR strength
            strength = entry_zone.get('strength', 'MEDIUM')
            if strength == 'STRONG':
                base_score = 70
            elif strength == 'MEDIUM':
                base_score = 50
            else:
                base_score = 30

            # Add points for each confluent factor
            htf_bonus = len(htf_in_zone) * 10  # +10 per HTF pivot in zone
            fib_bonus = len(fib_in_zone) * 8   # +8 per Fib level in zone
            bos_bonus = len(bos_in_zone) * 7   # +7 per BOS level in zone
            choch_bonus = len(choch_in_zone) * 6  # +6 per CHOCH level in zone
            reversal_bonus = len(reversal_in_zone) * 5  # +5 per Reversal target in zone

            # Extra bonus for key Fib levels (0.618, 0.382)
            key_fib_bonus = sum(5 for f in fib_in_zone if '0.618' in f.get('label', '') or '0.382' in f.get('label', ''))

            # Calculate total reversal probability
            reversal_probability = min(99, base_score + htf_bonus + fib_bonus + bos_bonus + choch_bonus + reversal_bonus + key_fib_bonus)

            # Determine exact reversal price (average of ALL confluent levels)
            confluent_prices = [oi['price']]
            confluent_prices.extend([h['price'] for h in htf_in_zone])
            confluent_prices.extend([f['price'] for f in fib_in_zone])
            confluent_prices.extend([b['price'] for b in bos_in_zone])
            confluent_prices.extend([c['price'] for c in choch_in_zone])
            confluent_prices.extend([r['price'] for r in reversal_in_zone])
            exact_reversal_price = round(sum(confluent_prices) / len(confluent_prices), 2)

            # Build confluence label
            confluence_parts = []
            if htf_in_zone:
                htf_names = [h['label'].split()[0] for h in htf_in_zone]  # Get timeframe names
                confluence_parts.append(f"HTF:{'+'.join(htf_names)}")
            if fib_in_zone:
                fib_names = [f['label'].split('%')[0] + '%' for f in fib_in_zone]
                confluence_parts.append(f"Fib:{'+'.join(fib_names)}")
            if bos_in_zone:
                confluence_parts.append(f"BOS:{len(bos_in_zone)}")
            if choch_in_zone:
                confluence_parts.append(f"CHOCH:{len(choch_in_zone)}")
            if reversal_in_zone:
                confluence_parts.append(f"RevZone:{len(reversal_in_zone)}")

            # Create enhanced OI Wall entry
            enhanced_entry = {
                'price': oi['price'],
                'source': 'OI-Wall',
                'label': oi['label'],
                'priority': SOURCE_PRIORITY['OI-Wall'],
                'strike_pcr': strike_pcr,
                'entry_zone': entry_zone,
                'reversal_probability': reversal_probability,
                'exact_reversal_price': exact_reversal_price,
                'confluent_htf': [h['label'] for h in htf_in_zone],
                'confluent_fib': [f['label'] for f in fib_in_zone],
                'confluent_bos': [b['label'] for b in bos_in_zone],
                'confluent_choch': [c['label'] for c in choch_in_zone],
                'confluent_reversal': [r['label'] for r in reversal_in_zone],
            }

            # If high confluence, mark as EXACT REVERSAL ZONE
            if reversal_probability >= 75:
                enhanced_entry['is_exact_reversal'] = True
                enhanced_entry['label'] = f"{oi['label']} ğŸ¯ REVERSAL {reversal_probability}%"
                if confluence_parts:
                    enhanced_entry['confluence_detail'] = ' + '.join(confluence_parts)

            enhanced_oi_walls.append(enhanced_entry)

        # Also check for HTF + Fib confluence (without OI Wall)
        confluence_found = []
        for i, htf in enumerate(htf_levels):
            if i in used_htf:
                continue
            for j, fib in enumerate(fib_levels):
                if j in used_fib:
                    continue
                if abs(htf['price'] - fib['price']) <= CONFLUENCE_TOLERANCE:
                    avg_price = (htf['price'] + fib['price']) / 2
                    confluence_found.append({
                        'price': round(avg_price, 2),
                        'source': 'Confluence',
                        'label': f"HTF+{fib['label']} âš¡",
                        'priority': 95,
                        'reversal_probability': 65  # Lower than OI Wall confluence
                    })
                    used_htf.add(i)
                    used_fib.add(j)

        # Keep non-confluence levels
        remaining_htf = [l for i, l in enumerate(htf_levels) if i not in used_htf]
        remaining_fib = [l for j, l in enumerate(fib_levels) if j not in used_fib]
        remaining_bos = [l for k, l in enumerate(bos_levels) if k not in used_bos]
        remaining_choch = [l for m, l in enumerate(choch_levels) if m not in used_choch]
        remaining_reversal = [l for n, l in enumerate(reversal_levels) if n not in used_reversal]

        # OI Walls without entry_zone (legacy)
        legacy_oi_walls = [l for l in levels if l['source'] == 'OI-Wall' and not l.get('entry_zone')]

        return (enhanced_oi_walls + legacy_oi_walls + confluence_found +
                remaining_htf + remaining_fib + remaining_bos + remaining_choch + remaining_reversal + other_levels)

    # Apply EXACT REVERSAL detection
    exact_supports = find_exact_reversal_zones(exact_supports, is_support=True)
    exact_resistances = find_exact_reversal_zones(exact_resistances, is_support=False)

    # Add Confluence to priority if not exists
    if 'Confluence' not in SOURCE_PRIORITY:
        SOURCE_PRIORITY['Confluence'] = 95

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # SORT BY PRIORITY (OI Wall first, then Confluence, then Fib, then others)
    # Remove duplicates (same price within 5 points)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    def dedupe_and_sort(levels, is_support=True):
        """Remove near-duplicates and sort by priority"""
        if not levels:
            return []

        # Sort by priority (highest first)
        sorted_levels = sorted(levels, key=lambda x: -x['priority'])

        # Remove duplicates within 5 points (keep higher priority)
        deduped = []
        for lvl in sorted_levels:
            is_dup = False
            for existing in deduped:
                if abs(lvl['price'] - existing['price']) <= 5:
                    is_dup = True
                    break
            if not is_dup:
                deduped.append(lvl)

        # For supports, sort by proximity to spot (closest first)
        # For resistances, sort by proximity to spot (closest first)
        if is_support:
            deduped = sorted(deduped, key=lambda x: -(x['price']))  # Highest support first (closest to spot)
        else:
            deduped = sorted(deduped, key=lambda x: x['price'])    # Lowest resistance first (closest to spot)

        return deduped[:5]  # Top 5 levels

    merged_supports = dedupe_and_sort(exact_supports, is_support=True)
    merged_resistances = dedupe_and_sort(exact_resistances, is_support=False)

    # FALLBACK - Always show S/R even if sources are empty
    if not merged_supports:
        if spot_price and spot_price > 0:
            base = int(spot_price / 50) * 50  # Align to 50-point strikes
            merged_supports = [
                {'price': base - 50, 'source': 'Round', 'label': f'Strike â‚¹{base-50:,.0f}', 'priority': 30},
                {'price': base - 100, 'source': 'Round', 'label': f'Strike â‚¹{base-100:,.0f}', 'priority': 30}
            ]
        elif signal.atm_strike and signal.atm_strike > 0:
            atm = signal.atm_strike
            merged_supports = [
                {'price': atm - 50, 'source': 'ATM', 'label': f'ATM-50', 'priority': 25},
                {'price': atm - 100, 'source': 'ATM', 'label': f'ATM-100', 'priority': 25}
            ]

    if not merged_resistances:
        if spot_price and spot_price > 0:
            base = int(spot_price / 50) * 50  # Align to 50-point strikes
            merged_resistances = [
                {'price': base + 50, 'source': 'Round', 'label': f'Strike â‚¹{base+50:,.0f}', 'priority': 30},
                {'price': base + 100, 'source': 'Round', 'label': f'Strike â‚¹{base+100:,.0f}', 'priority': 30}
            ]
        elif signal.atm_strike and signal.atm_strike > 0:
            atm = signal.atm_strike
            merged_resistances = [
                {'price': atm + 50, 'source': 'ATM', 'label': f'ATM+50', 'priority': 25},
                {'price': atm + 100, 'source': 'ATM', 'label': f'ATM+100', 'priority': 25}
            ]

    # Get primary S/R for display
    support = merged_supports[0]['price'] if merged_supports else 0
    resistance = merged_resistances[0]['price'] if merged_resistances else 0

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ¯ AUTO ENTRY SIGNAL - Check if price in exact reversal zone
    # Send Telegram alert when price enters high-probability reversal zone
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    auto_entry_enabled = st.session_state.get('auto_entry_telegram', True)
    if spot_price and auto_entry_enabled:
        triggered_entries = check_and_send_reversal_entry(
            spot_price=spot_price,
            support_levels=merged_supports,
            resistance_levels=merged_resistances,
            auto_send=True
        )
        # Store triggered entries for display
        if triggered_entries:
            st.session_state['last_triggered_entries'] = triggered_entries

    # Build signals text
    signals_text = ""
    if signals_list:
        for sig in signals_list[:4]:
            sig_color = "#00ff00" if "bull" in sig.lower() or "buy" in sig.lower() or "up" in sig.lower() else "#ff4444" if "bear" in sig.lower() or "sell" in sig.lower() or "down" in sig.lower() else "#aaa"
            signals_text += f'<span style="color: {sig_color};">â€¢ {sig}</span><br>'

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ML MARKET REGIME ASSESSMENT - Using Streamlit Components
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    st.markdown("---")
    st.subheader("ğŸ“Š ML MARKET REGIME ASSESSMENT")

    # Row 1: Regime and Confidence
    col1, col2 = st.columns(2)
    with col1:
        st.metric(label="Market Regime", value=f"{regime_emoji} {regime}")
    with col2:
        st.metric(label="Confidence", value=f"{confidence:.0f}%")

    # Row 2: Market Phase and Sentiment
    col3, col4 = st.columns(2)
    with col3:
        st.markdown(f"**Market Phase:** {market_phase}")
        st.caption(f"ğŸ’¡ {phase_explanation}")
    with col4:
        sent_emoji = "ğŸŸ¢" if "LONG" in str(trading_sentiment) else "ğŸ”´" if "SHORT" in str(trading_sentiment) else "ğŸŸ¡"
        st.markdown(f"**Trading Sentiment:** {sent_emoji} {trading_sentiment}")
        st.caption(f"Score: {sentiment_score:+.0f}")

    # Row 3: Technical Details
    col5, col6, col7 = st.columns(3)
    with col5:
        st.markdown(f"**Trend Strength:** {trend_strength:.0f}%")
    with col6:
        st.markdown(f"**Volatility:** {volatility_state}")
    with col7:
        st.markdown(f"**Timeframe:** {optimal_timeframe}")

    # Row 4: Trading Range (S/R from Option Chain + Chart)
    primary_supp = merged_supports[0]['price'] if merged_supports else 0
    primary_res = merged_resistances[0]['price'] if merged_resistances else 0
    range_size = abs(primary_res - primary_supp) if primary_supp and primary_res else 0

    if primary_supp > 0 or primary_res > 0:
        st.markdown("---")
        st.markdown("**ğŸ“Š EXACT S/R LEVELS (OI Wall = Primary)**")
        col_s, col_r, col_range = st.columns(3)
        with col_s:
            supp_label = merged_supports[0].get('label', 'Support') if merged_supports else "N/A"
            st.metric("ğŸ›¡ï¸ Support", f"â‚¹{primary_supp:,.0f}", delta=None, help=supp_label)
        with col_r:
            res_label = merged_resistances[0].get('label', 'Resistance') if merged_resistances else "N/A"
            st.metric("ğŸ§± Resistance", f"â‚¹{primary_res:,.0f}", delta=None, help=res_label)
        with col_range:
            st.metric("ğŸ“ Range", f"{range_size:,.0f} pts", delta=None)

        # Show current position in range
        if spot_price and primary_supp and primary_res and range_size > 0:
            position_pct = ((spot_price - primary_supp) / range_size) * 100
            position_pct = max(0, min(100, position_pct))  # Clamp 0-100
            if position_pct > 70:
                st.warning(f"âš ï¸ Price near RESISTANCE ({position_pct:.0f}% of range) - Watch for rejection")
            elif position_pct < 30:
                st.warning(f"âš ï¸ Price near SUPPORT ({position_pct:.0f}% of range) - Watch for bounce")
            else:
                st.info(f"ğŸ“ Price at {position_pct:.0f}% of range (Mid-zone)")

    # Recommended Strategy
    st.info(f"ğŸ“Œ **Recommended Strategy:** {recommended_strategy}")

    # Signals list
    if signals_list:
        with st.expander("ğŸ“¡ Active Signals", expanded=False):
            for sig in signals_list[:4]:
                if "bull" in sig.lower() or "buy" in sig.lower() or "up" in sig.lower():
                    st.success(f"â€¢ {sig}")
                elif "bear" in sig.lower() or "sell" in sig.lower() or "down" in sig.lower():
                    st.error(f"â€¢ {sig}")
                else:
                    st.write(f"â€¢ {sig}")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ¯ AUTO ENTRY TELEGRAM SETTINGS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    st.markdown("---")
    entry_col1, entry_col2 = st.columns([2, 1])
    with entry_col1:
        st.subheader("ğŸ¯ Exact Reversal Entry Signals")
    with entry_col2:
        auto_entry = st.checkbox("ğŸ“± Auto Telegram Entry", value=True, key="auto_entry_telegram")

    # Show triggered entry signals with Killer analysis
    last_entries = st.session_state.get('last_triggered_entries', [])
    if last_entries:
        for entry in last_entries:
            killer_score = entry.get('killer_score', 100)
            killer_allowed = entry.get('killer_allowed', True)

            if entry.get('success'):
                st.success(f"âœ… Entry Signal Sent: {entry['type']} at â‚¹{entry['price']:,.0f} | Killer Score: {killer_score:.0f}/100")
            elif not killer_allowed:
                # Entry blocked by Expiry Day Killer
                st.error(f"ğŸ›‘ BLOCKED BY KILLER: {entry['type']} at â‚¹{entry['price']:,.0f} | Score: {killer_score:.0f}/100")
                block_reasons = entry.get('block_reasons', [])
                if block_reasons:
                    for reason in block_reasons[:2]:
                        st.caption(f"   âš ï¸ {reason}")
            else:
                st.warning(f"âš ï¸ {entry['type']}: {entry.get('message', 'Not sent')}")

    # Show last Killer analysis result
    killer_result = st.session_state.get('last_killer_result')
    if killer_result is not None:
        with st.expander("ğŸ›¡ï¸ Expiry Day Killer Analysis", expanded=False):
            col_k1, col_k2, col_k3 = st.columns(3)
            with col_k1:
                risk_color = "green" if killer_result.risk_level == "LOW" else "orange" if killer_result.risk_level == "MEDIUM" else "red"
                st.metric("Safety Score", f"{killer_result.overall_score:.0f}/100")
            with col_k2:
                st.metric("Risk Level", killer_result.risk_level)
            with col_k3:
                st.metric("Volume", f"{killer_result.volume_ratio:.1f}x")

            st.markdown("**Filter Results:**")
            filter_cols = st.columns(5)
            with filter_cols[0]:
                st.caption(f"Time: {killer_result.time_filter.value}")
            with filter_cols[1]:
                st.caption(f"Volume: {killer_result.volume_filter.value}")
            with filter_cols[2]:
                st.caption(f"Retest: {killer_result.retest_filter.value}")
            with filter_cols[3]:
                st.caption(f"OI Wall: {killer_result.oi_wall_filter.value}")
            with filter_cols[4]:
                st.caption(f"Max Pain: {killer_result.max_pain_filter.value}")

            if killer_result.block_reasons:
                st.error("Block Reasons: " + " | ".join(killer_result.block_reasons[:2]))
            if killer_result.warning_reasons:
                st.warning("Warnings: " + " | ".join(killer_result.warning_reasons[:2]))

    # Show current distance to reversal zones
    if spot_price:
        for supp in merged_supports[:2]:
            if supp.get('is_exact_reversal') and supp.get('entry_zone'):
                zone = supp['entry_zone']
                dist = spot_price - zone.get('entry_to', supp['price'])
                if dist > 0:
                    st.info(f"ğŸ“ SUPPORT Entry Zone: â‚¹{zone['entry_from']:,.0f} - â‚¹{zone['entry_to']:,.0f} | Distance: {dist:.0f} pts away")
                else:
                    st.success(f"ğŸ¯ IN SUPPORT ZONE: â‚¹{zone['entry_from']:,.0f} - â‚¹{zone['entry_to']:,.0f} | Reversal: {supp.get('reversal_probability', 0)}%")

        for res in merged_resistances[:2]:
            if res.get('is_exact_reversal') and res.get('entry_zone'):
                zone = res['entry_zone']
                dist = zone.get('entry_from', res['price']) - spot_price
                if dist > 0:
                    st.info(f"ğŸ“ RESISTANCE Entry Zone: â‚¹{zone['entry_from']:,.0f} - â‚¹{zone['entry_to']:,.0f} | Distance: {dist:.0f} pts away")
                else:
                    st.error(f"ğŸ¯ IN RESISTANCE ZONE: â‚¹{zone['entry_from']:,.0f} - â‚¹{zone['entry_to']:,.0f} | Reversal: {res.get('reversal_probability', 0)}%")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ“Š EXACT SUPPORT/RESISTANCE LEVELS - Python Components
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if merged_supports or merged_resistances:
        st.markdown("---")
        st.subheader("ğŸ“Š EXACT SUPPORT & RESISTANCE LEVELS")
        st.caption("OI Wall = Primary | Fib = Secondary | Exact prices only")

        col_s, col_r = st.columns(2)

        with col_s:
            st.markdown("**ğŸ›¡ï¸ SUPPORT LEVELS (Market won't go below)**")
            if merged_supports:
                for i, s in enumerate(merged_supports[:5]):
                    # Priority indicator: OI-Wall gets â˜…â˜…â˜…, Fib gets â˜…â˜…, others get â˜…
                    priority = s.get('priority', 30)
                    if priority >= 90:
                        stars = "â˜…â˜…â˜…"  # OI Wall / Max Pain
                    elif priority >= 70:
                        stars = "â˜…â˜…"   # Fib 0.618/0.382/Swing
                    else:
                        stars = "â˜…"    # HTF/VWAP/Round
                    label = s.get('label', 'Support')

                    # Check for EXACT REVERSAL zone
                    reversal_prob = s.get('reversal_probability', 0)
                    if s.get('is_exact_reversal') and reversal_prob >= 75:
                        st.success(f"ğŸ¯ S{i+1}: â‚¹{s['price']:,.0f} | REVERSAL {reversal_prob}% â˜…â˜…â˜…")
                        # Show exact reversal price
                        exact_price = s.get('exact_reversal_price', s['price'])
                        st.caption(f"   ğŸ¯ EXACT REVERSAL: â‚¹{exact_price:,.0f}")
                        # Show confluence details
                        if s.get('confluence_detail'):
                            st.caption(f"   âš¡ Confluence: {s['confluence_detail']}")
                    else:
                        st.success(f"S{i+1}: â‚¹{s['price']:,.0f} | {label} {stars}")

                    # Show entry zone for OI Wall with PCR
                    entry_zone = s.get('entry_zone')
                    if entry_zone and s.get('source') == 'OI-Wall':
                        st.caption(f"   ğŸ“ Entry Zone: â‚¹{entry_zone['entry_from']:,.0f} - â‚¹{entry_zone['entry_to']:,.0f} ({entry_zone['buffer']})")
                        # Show confluent factors if any
                        htf_list = s.get('confluent_htf', [])
                        fib_list = s.get('confluent_fib', [])
                        if htf_list:
                            st.caption(f"   ğŸ“Š HTF Pivots: {', '.join(htf_list)}")
                        if fib_list:
                            st.caption(f"   ğŸ“ Fib Levels: {', '.join(fib_list)}")
            else:
                st.caption("No support levels detected")

        with col_r:
            st.markdown("**ğŸ§± RESISTANCE LEVELS (Market won't go above)**")
            if merged_resistances:
                for i, r in enumerate(merged_resistances[:5]):
                    # Priority indicator
                    priority = r.get('priority', 30)
                    if priority >= 90:
                        stars = "â˜…â˜…â˜…"  # OI Wall / Max Pain
                    elif priority >= 70:
                        stars = "â˜…â˜…"   # Fib 0.618/0.382/Swing
                    else:
                        stars = "â˜…"    # HTF/VWAP/Round
                    label = r.get('label', 'Resistance')

                    # Check for EXACT REVERSAL zone
                    reversal_prob = r.get('reversal_probability', 0)
                    if r.get('is_exact_reversal') and reversal_prob >= 75:
                        st.error(f"ğŸ¯ R{i+1}: â‚¹{r['price']:,.0f} | REVERSAL {reversal_prob}% â˜…â˜…â˜…")
                        # Show exact reversal price
                        exact_price = r.get('exact_reversal_price', r['price'])
                        st.caption(f"   ğŸ¯ EXACT REVERSAL: â‚¹{exact_price:,.0f}")
                        # Show confluence details
                        if r.get('confluence_detail'):
                            st.caption(f"   âš¡ Confluence: {r['confluence_detail']}")
                    else:
                        st.error(f"R{i+1}: â‚¹{r['price']:,.0f} | {label} {stars}")

                    # Show entry zone for OI Wall with PCR
                    entry_zone = r.get('entry_zone')
                    if entry_zone and r.get('source') == 'OI-Wall':
                        st.caption(f"   ğŸ“ Entry Zone: â‚¹{entry_zone['entry_from']:,.0f} - â‚¹{entry_zone['entry_to']:,.0f} ({entry_zone['buffer']})")
                        # Show confluent factors if any
                        htf_list = r.get('confluent_htf', [])
                        fib_list = r.get('confluent_fib', [])
                        if htf_list:
                            st.caption(f"   ğŸ“Š HTF Pivots: {', '.join(htf_list)}")
                        if fib_list:
                            st.caption(f"   ğŸ“ Fib Levels: {', '.join(fib_list)}")
            else:
                st.caption("No resistance levels detected")

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # ğŸ“ PCR-BASED ENTRY ZONE REFERENCE (Show how S/R width changes with PCR)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        st.markdown("---")
        st.markdown("**ğŸ“ PCR-Based Entry Zone Reference**")
        st.caption("How Support/Resistance zones vary based on Strike PCR")

        pcr_col1, pcr_col2 = st.columns(2)

        with pcr_col1:
            st.markdown("""
**ğŸ›¡ï¸ SUPPORT Entry Zones (PUT OI Wall)**
| PCR | Strength | Entry Zone |
|-----|----------|------------|
| â‰¥3.0 | ğŸŸ¢ STRONG | Strike +20 (reverses early) |
| 2.0-3.0 | ğŸŸ¢ STRONG | Strike Â±10 |
| 1.5-2.0 | ğŸŸ¡ MEDIUM | Strike -15 to +5 |
| <1.5 | ğŸ”´ WEAK | Strike -20 (may dip below) |
""")

        with pcr_col2:
            st.markdown("""
**ğŸ§± RESISTANCE Entry Zones (CALL OI Wall)**
| PCR | Strength | Entry Zone |
|-----|----------|------------|
| â‰¤0.4 | ğŸŸ¢ STRONG | Strike -20 (reverses early) |
| 0.4-0.5 | ğŸŸ¢ STRONG | Strike Â±10 |
| 0.5-0.7 | ğŸŸ¡ MEDIUM | Strike -5 to +15 |
| >0.7 | ğŸ”´ WEAK | Strike +20 (may push above) |
""")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ¯ FINAL ASSESSMENT - Clear Directional Call
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Determine overall market direction
    is_bullish = signal.signal in ['STRONG BUY', 'BUY'] or (trading_sentiment and 'LONG' in trading_sentiment)
    is_bearish = signal.signal in ['STRONG SELL', 'SELL'] or (trading_sentiment and 'SHORT' in trading_sentiment)

    # Get key levels
    primary_support = merged_supports[0]['price'] if merged_supports else 0
    primary_resistance = merged_resistances[0]['price'] if merged_resistances else 0
    current_price = spot_price or 0

    # Calculate distances
    dist_to_support = abs(current_price - primary_support) if primary_support and current_price else 999
    dist_to_resistance = abs(primary_resistance - current_price) if primary_resistance and current_price else 999

    # Determine if near key level (within 30 points)
    near_support = dist_to_support < 30
    near_resistance = dist_to_resistance < 30

    # Build assessment
    if is_bullish:
        direction_color = "#00ff00"
        direction_emoji = "ğŸ‚"
        direction_text = "BULLISH"

        if near_resistance:
            # Bullish but near resistance - potential reversal
            assessment_text = f"âš ï¸ CAUTION: Market is BULLISH but approaching RESISTANCE at â‚¹{primary_resistance:,.0f}. Watch for reversal or breakout."
            move_text = f"If breakout above â‚¹{primary_resistance:,.0f} â†’ Next target: â‚¹{primary_resistance + 100:,.0f}"
            reversal_text = f"If rejection at â‚¹{primary_resistance:,.0f} â†’ Pullback to â‚¹{primary_support:,.0f}"
        else:
            assessment_text = f"ğŸ“ˆ Market will RISE from Support â‚¹{primary_support:,.0f} towards Resistance â‚¹{primary_resistance:,.0f}"
            move_text = f"Expected Move: â‚¹{primary_support:,.0f} â†’ â‚¹{primary_resistance:,.0f} ({primary_resistance - primary_support:,.0f} points)"
            reversal_text = f"ğŸ”„ Reversal Zone: If price falls below â‚¹{primary_support:,.0f}, trend may reverse to BEARISH"

    elif is_bearish:
        direction_color = "#ff4444"
        direction_emoji = "ğŸ»"
        direction_text = "BEARISH"

        if near_support:
            # Bearish but near support - potential reversal
            assessment_text = f"âš ï¸ CAUTION: Market is BEARISH but approaching SUPPORT at â‚¹{primary_support:,.0f}. Watch for reversal or breakdown."
            move_text = f"If breakdown below â‚¹{primary_support:,.0f} â†’ Next target: â‚¹{primary_support - 100:,.0f}"
            reversal_text = f"If bounce from â‚¹{primary_support:,.0f} â†’ Rally to â‚¹{primary_resistance:,.0f}"
        else:
            assessment_text = f"ğŸ“‰ Market will FALL from Resistance â‚¹{primary_resistance:,.0f} towards Support â‚¹{primary_support:,.0f}"
            move_text = f"Expected Move: â‚¹{primary_resistance:,.0f} â†’ â‚¹{primary_support:,.0f} ({primary_resistance - primary_support:,.0f} points)"
            reversal_text = f"ğŸ”„ Reversal Zone: If price rises above â‚¹{primary_resistance:,.0f}, trend may reverse to BULLISH"

    else:
        direction_color = "#ffaa00"
        direction_emoji = "â†”ï¸"
        direction_text = "NEUTRAL/RANGE"
        assessment_text = f"â†”ï¸ Market is RANGE-BOUND between â‚¹{primary_support:,.0f} and â‚¹{primary_resistance:,.0f}"
        move_text = f"Trade the Range: BUY near â‚¹{primary_support:,.0f} | SELL near â‚¹{primary_resistance:,.0f}"
        reversal_text = f"ğŸš€ Breakout Watch: Above â‚¹{primary_resistance:,.0f} = BULLISH | Below â‚¹{primary_support:,.0f} = BEARISH"

    if primary_support > 0 or primary_resistance > 0:
        st.markdown("---")
        st.subheader("ğŸ¯ FINAL ASSESSMENT")

        # Direction badge
        col_dir, col_badge = st.columns([3, 1])
        with col_dir:
            st.markdown(f"**Direction:** {direction_emoji} **{direction_text}**")
        with col_badge:
            if is_bullish:
                st.success(f"{direction_emoji} {direction_text}")
            elif is_bearish:
                st.error(f"{direction_emoji} {direction_text}")
            else:
                st.warning(f"{direction_emoji} {direction_text}")

        # Assessment text
        if is_bullish:
            if near_resistance:
                st.warning(assessment_text)
            else:
                st.success(assessment_text)
        elif is_bearish:
            if near_support:
                st.warning(assessment_text)
            else:
                st.error(assessment_text)
        else:
            st.info(assessment_text)

        # Move and Reversal
        st.markdown(f"**ğŸ“Š {move_text}**")
        st.caption(reversal_text)

        # Distance metrics
        col_p1, col_p2, col_p3 = st.columns(3)
        with col_p1:
            st.metric("Current Price", f"â‚¹{current_price:,.0f}")
        with col_p2:
            st.metric("To Support", f"{dist_to_support:,.0f} pts", delta=None)
        with col_p3:
            st.metric("To Resistance", f"{dist_to_resistance:,.0f} pts", delta=None)

    # Show ATM Option Recommendation based on signal
    st.markdown("---")
    if signal.signal in ['STRONG BUY', 'BUY'] and signal.atm_call_ltp > 0:
        st.subheader("ğŸ“ˆ BUY ATM CALL")
        col_atm1, col_atm2 = st.columns(2)
        with col_atm1:
            st.metric("Strike", f"â‚¹{signal.atm_strike:,.0f}")
        with col_atm2:
            st.metric("LTP", f"â‚¹{signal.atm_call_ltp:,.2f}")
        st.success(f"**RECOMMENDATION:** BUY {signal.atm_strike:.0f} CE @ â‚¹{signal.atm_call_ltp:.2f}")

    elif signal.signal in ['STRONG SELL', 'SELL'] and signal.atm_put_ltp > 0:
        st.subheader("ğŸ“‰ BUY ATM PUT")
        col_atm1, col_atm2 = st.columns(2)
        with col_atm1:
            st.metric("Strike", f"â‚¹{signal.atm_strike:,.0f}")
        with col_atm2:
            st.metric("LTP", f"â‚¹{signal.atm_put_ltp:,.2f}")
        st.error(f"**RECOMMENDATION:** BUY {signal.atm_strike:.0f} PE @ â‚¹{signal.atm_put_ltp:.2f}")

    # Send to Telegram for BUY/SELL signals (with auto-send option)
    if signal.signal in ['STRONG BUY', 'BUY', 'STRONG SELL', 'SELL']:
        tg_col1, tg_col2 = st.columns([3, 1])
        with tg_col1:
            auto_send = st.checkbox("ğŸ“± Auto-send to Telegram", value=True, key="ml_signal_auto_telegram")
        with tg_col2:
            manual_send = st.button("ğŸ“¤ Send Now", key="ml_signal_manual_telegram")

        # Auto-send or manual send
        if auto_send or manual_send:
            success, msg = send_ml_signal_telegram(signal, spot_price)
            if success:
                st.success(f"âœ… {msg}")
            elif "already sent" not in msg.lower() and "not configured" not in msg.lower():
                st.warning(f"âš ï¸ {msg}")

    # Metrics row 1
    col1, col2, col3, col4, col5, col6 = st.columns(6)

    with col1:
        st.metric("Regime", signal.regime, f"{signal.regime_score:+.0f}")

    with col2:
        st.metric("Volatility", signal.volatility_state, f"{signal.volatility_score:.0f}%")

    with col3:
        st.metric("OI Trap", signal.trap_warning[:12], f"{signal.oi_trap_score:+.0f}")

    with col4:
        st.metric("CVD", f"{signal.cvd_score:+.0f}", "Bull" if signal.cvd_score > 0 else "Bear" if signal.cvd_score < 0 else "-")

    with col5:
        st.metric("Expiry", f"{signal.days_to_expiry:.1f}d", signal.expiry_warning[:10])

    with col6:
        st.metric("Position", f"{signal.position_size_multiplier:.1f}x", signal.risk_level)

    st.divider()

    # Strategy recommendation
    st.info(f"ğŸ“Š **Strategy:** {signal.recommended_strategy}")

    # Entry/Exit levels
    if signal.signal != "HOLD" and spot_price:
        col1, col2 = st.columns(2)

        with col1:
            st.markdown("### ğŸ¯ Entry Zone")
            st.write(f"**Entry:** â‚¹{signal.entry_zone[0]:,.0f} - â‚¹{signal.entry_zone[1]:,.0f}")
            st.write(f"**Stop Loss:** â‚¹{signal.stop_loss:,.0f}")

        with col2:
            st.markdown("### ğŸ¯ Targets")
            for i, target in enumerate(signal.targets, 1):
                st.write(f"**T{i}:** â‚¹{target:,.0f}")

    # Reasons
    col1, col2 = st.columns(2)

    with col1:
        if signal.bullish_reasons:
            st.markdown("### ğŸ‚ Bullish Signals")
            for reason in signal.bullish_reasons:
                st.success(f"âœ… {reason}")

    with col2:
        if signal.bearish_reasons:
            st.markdown("### ğŸ» Bearish Signals")
            for reason in signal.bearish_reasons:
                st.error(f"âš ï¸ {reason}")

    # Component scores chart
    with st.expander("ğŸ“Š Component Scores Breakdown"):
        scores_df = pd.DataFrame({
            'Component': ['Regime', 'XGBoost', 'Volatility', 'OI Trap', 'CVD', 'Liquidity'],
            'Score': [
                signal.regime_score,
                signal.xgboost_score,
                signal.volatility_score - 50,  # Normalize to -50 to +50
                signal.oi_trap_score,
                signal.cvd_score,
                signal.liquidity_score
            ]
        })

        import plotly.express as px
        fig = px.bar(
            scores_df,
            x='Component',
            y='Score',
            color='Score',
            color_continuous_scale=['red', 'yellow', 'green'],
            range_color=[-100, 100]
        )
        fig.update_layout(height=300)
        st.plotly_chart(fig, use_container_width=True)


def get_cached_unified_signal() -> Optional[UnifiedSignal]:
    """Get cached unified signal from session state"""
    return st.session_state.get('unified_ml_signal')
