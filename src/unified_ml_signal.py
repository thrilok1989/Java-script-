"""
Unified ML Trading Signal
==========================
Combines ALL ML modules into a SINGLE trading signal

Modules Combined:
1. ML Market Regime Detection
2. XGBoost Prediction (BUY/SELL/HOLD)
3. Volatility Regime
4. OI Trap Detection
5. CVD Delta Imbalance
6. Liquidity Gravity Analysis
7. Institutional vs Retail Detection

Output: Single unified trading signal with confidence score
"""

import streamlit as st
import pandas as pd
import numpy as np
import requests
from datetime import datetime
from typing import Dict, Any, Optional, Tuple
from dataclasses import dataclass
import logging

logger = logging.getLogger(__name__)


def send_ml_signal_telegram(signal, spot_price: float = None):
    """
    Send ML Signal to Telegram when BUY/SELL signal is generated
    """
    try:
        # Get Telegram credentials from secrets
        bot_token = st.secrets.get("TELEGRAM_BOT_TOKEN", "")
        chat_id = st.secrets.get("TELEGRAM_CHAT_ID", "")

        if not bot_token or not chat_id:
            return False, "Telegram not configured"

        # Check if we already sent this signal (avoid duplicates)
        signal_key = f"{signal.signal}_{signal.atm_strike}_{signal.timestamp.strftime('%Y%m%d%H%M')}"
        if 'last_ml_telegram_signal' in st.session_state:
            if st.session_state.last_ml_telegram_signal == signal_key:
                return False, "Signal already sent"

        # Build the message
        if signal.signal in ['STRONG BUY', 'BUY']:
            emoji = "ğŸŸ¢ğŸ“ˆ"
            option_type = "CALL"
            option_ltp = signal.atm_call_ltp
        elif signal.signal in ['STRONG SELL', 'SELL']:
            emoji = "ğŸ”´ğŸ“‰"
            option_type = "PUT"
            option_ltp = signal.atm_put_ltp
        else:
            return False, "No actionable signal"

        # Format targets
        targets_str = ""
        if signal.targets:
            for i, t in enumerate(signal.targets, 1):
                targets_str += f"T{i}: â‚¹{t:,.0f}\n"

        # Build message
        message = f"""
{emoji} *ML TRADING SIGNAL* {emoji}

ğŸ¯ *Signal:* {signal.signal}
ğŸ“Š *Confidence:* {signal.confidence:.0f}%
âš ï¸ *Risk Level:* {signal.risk_level}

ğŸ’° *Trade Setup:*
â€¢ ATM Strike: â‚¹{signal.atm_strike:,.0f}
â€¢ Option: BUY {option_type}
â€¢ LTP: â‚¹{option_ltp:,.2f}

ğŸ“ˆ *Strategy:* {signal.recommended_strategy}

ğŸ¯ *Entry Zone:* â‚¹{signal.entry_zone[0]:,.0f} - â‚¹{signal.entry_zone[1]:,.0f}
ğŸ›‘ *Stop Loss:* â‚¹{signal.stop_loss:,.0f}

ğŸ¯ *Targets:*
{targets_str}
ğŸ“Š *Market Regime:* {signal.regime}
ğŸ“‰ *Volatility:* {signal.volatility_state}
â° *Expiry:* {signal.days_to_expiry:.1f} days

âš¡ _Generated by ML Signal Engine_
"""

        # Send to Telegram
        url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
        payload = {
            "chat_id": chat_id,
            "text": message,
            "parse_mode": "Markdown",
            "disable_web_page_preview": True
        }
        response = requests.post(url, json=payload, timeout=10)

        if response.status_code == 200:
            # Store signal key to avoid duplicates
            st.session_state.last_ml_telegram_signal = signal_key
            return True, "Signal sent to Telegram!"
        else:
            return False, f"Failed: {response.status_code}"

    except Exception as e:
        logger.error(f"Telegram send error: {e}")
        return False, f"Error: {str(e)}"


@dataclass
class UnifiedSignal:
    """Unified Trading Signal"""
    signal: str  # "STRONG BUY", "BUY", "HOLD", "SELL", "STRONG SELL"
    confidence: float  # 0-100

    # Component scores
    regime_score: float  # -100 to +100
    xgboost_score: float  # -100 to +100
    volatility_score: float  # 0 to 100
    oi_trap_score: float  # -100 to +100
    cvd_score: float  # -100 to +100
    liquidity_score: float  # -100 to +100
    expiry_score: float  # 0 to 100 (risk score)

    # Details
    regime: str
    volatility_state: str
    trap_warning: str
    recommended_strategy: str

    # Expiry analysis
    days_to_expiry: float
    expiry_spike_probability: float
    expiry_spike_type: str
    expiry_warning: str

    # Risk metrics
    risk_level: str  # "LOW", "MEDIUM", "HIGH", "EXTREME"
    position_size_multiplier: float  # 0.25 to 1.5

    # Entry/Exit levels
    entry_zone: Tuple[float, float]
    stop_loss: float
    targets: list

    # Reasoning
    bullish_reasons: list
    bearish_reasons: list

    # ATM Option LTP for trade recommendation
    atm_strike: float = 0.0
    atm_call_ltp: float = 0.0
    atm_put_ltp: float = 0.0

    timestamp: datetime = None


class UnifiedMLSignalGenerator:
    """
    Generates a unified trading signal from all ML modules
    """

    def __init__(self):
        """Initialize the signal generator"""
        self.modules_loaded = {}
        self._load_modules()

    def _load_modules(self):
        """Load all ML modules"""
        # ML Market Regime
        try:
            from src.ml_market_regime import MLMarketRegimeDetector
            self.regime_detector = MLMarketRegimeDetector()
            self.modules_loaded['regime'] = True
        except ImportError:
            self.modules_loaded['regime'] = False
            self.regime_detector = None

        # XGBoost Analyzer
        try:
            from src.xgboost_ml_analyzer import XGBoostMLAnalyzer
            self.xgboost_analyzer = XGBoostMLAnalyzer()
            self.modules_loaded['xgboost'] = True
        except ImportError:
            self.modules_loaded['xgboost'] = False
            self.xgboost_analyzer = None

        # Volatility Regime
        try:
            from src.volatility_regime import VolatilityRegimeDetector
            self.volatility_detector = VolatilityRegimeDetector()
            self.modules_loaded['volatility'] = True
        except ImportError:
            self.modules_loaded['volatility'] = False
            self.volatility_detector = None

        # OI Trap Detection
        try:
            from src.oi_trap_detection import OITrapDetector
            self.oi_trap_detector = OITrapDetector()
            self.modules_loaded['oi_trap'] = True
        except ImportError:
            self.modules_loaded['oi_trap'] = False
            self.oi_trap_detector = None

        # CVD Analyzer
        try:
            from src.cvd_delta_imbalance import CVDAnalyzer
            self.cvd_analyzer = CVDAnalyzer()
            self.modules_loaded['cvd'] = True
        except ImportError:
            self.modules_loaded['cvd'] = False
            self.cvd_analyzer = None

        # Liquidity Analyzer
        try:
            from src.liquidity_gravity import LiquidityGravityAnalyzer
            self.liquidity_analyzer = LiquidityGravityAnalyzer()
            self.modules_loaded['liquidity'] = True
        except ImportError:
            self.modules_loaded['liquidity'] = False
            self.liquidity_analyzer = None

        # Institutional Detector
        try:
            from src.institutional_retail_detector import InstitutionalRetailDetector
            self.institutional_detector = InstitutionalRetailDetector()
            self.modules_loaded['institutional'] = True
        except ImportError:
            self.modules_loaded['institutional'] = False
            self.institutional_detector = None

    def generate_signal(
        self,
        df: pd.DataFrame,
        option_chain: Optional[Dict] = None,
        vix_current: Optional[float] = None,
        spot_price: Optional[float] = None,
        bias_results: Optional[Dict] = None
    ) -> UnifiedSignal:
        """
        Generate unified trading signal from all ML modules

        Args:
            df: Price DataFrame with OHLCV
            option_chain: Option chain data
            vix_current: Current VIX value
            spot_price: Current spot price
            bias_results: Results from Bias Analysis Pro

        Returns:
            UnifiedSignal with combined analysis
        """
        # Initialize scores
        scores = {
            'regime': 0,
            'xgboost': 0,
            'volatility': 50,  # Neutral default
            'oi_trap': 0,
            'cvd': 0,
            'liquidity': 0,
            'institutional': 0
        }

        bullish_reasons = []
        bearish_reasons = []

        regime_name = "Unknown"
        volatility_state = "Normal"
        trap_warning = "None"
        strategy = "Wait for confirmation"

        # Ensure ATR column exists (handle both 'High'/'Low' and 'high'/'low' columns)
        if 'ATR' not in df.columns:
            df = df.copy()
            # Check for column names (could be 'High' or 'high')
            high_col = 'High' if 'High' in df.columns else 'high' if 'high' in df.columns else None
            low_col = 'Low' if 'Low' in df.columns else 'low' if 'low' in df.columns else None
            if high_col and low_col:
                df['ATR'] = df[high_col] - df[low_col]
            else:
                df['ATR'] = 50  # Default ATR if columns missing

        # 1. ML Market Regime
        regime_result = None
        if self.regime_detector:
            try:
                regime_result = self.regime_detector.detect_regime(df)
                regime_name = regime_result.regime

                # Store full regime result in session state for display
                st.session_state['ml_regime_result'] = {
                    'regime': regime_result.regime,
                    'confidence': regime_result.confidence,
                    'trend_strength': regime_result.trend_strength,
                    'volatility_state': regime_result.volatility_state,
                    'market_phase': regime_result.market_phase,
                    'recommended_strategy': regime_result.recommended_strategy,
                    'optimal_timeframe': regime_result.optimal_timeframe,
                    'signals': regime_result.signals if hasattr(regime_result, 'signals') else [],
                    'trading_sentiment': getattr(regime_result, 'trading_sentiment', 'NEUTRAL'),
                    'sentiment_confidence': getattr(regime_result, 'sentiment_confidence', 0),
                    'sentiment_score': getattr(regime_result, 'sentiment_score', 0),
                    'support_resistance': getattr(regime_result, 'support_resistance', {}),
                    'entry_exit_signals': getattr(regime_result, 'entry_exit_signals', {})
                }

                # Convert regime to score (-100 to +100)
                if 'Up' in regime_name or 'BULLISH' in regime_name.upper():
                    scores['regime'] = min(regime_result.trend_strength * 1.5, 100)
                    bullish_reasons.append(f"Regime: {regime_name} (Trend: {regime_result.trend_strength:.0f}%)")
                elif 'Down' in regime_name or 'BEARISH' in regime_name.upper():
                    scores['regime'] = -min(regime_result.trend_strength * 1.5, 100)
                    bearish_reasons.append(f"Regime: {regime_name} (Trend: {regime_result.trend_strength:.0f}%)")
                else:
                    scores['regime'] = 0

                volatility_state = regime_result.volatility_state
                strategy = regime_result.recommended_strategy

            except Exception as e:
                logger.warning(f"Regime detection failed: {e}")

        # 2. Volatility Analysis
        if self.volatility_detector and vix_current:
            try:
                vol_result = self.volatility_detector.detect(df, vix_current)

                # Volatility affects position sizing, not direction
                if hasattr(vol_result, 'regime'):
                    vol_regime = str(vol_result.regime)
                    if 'Low' in vol_regime:
                        scores['volatility'] = 80
                        bullish_reasons.append("Low volatility - Good for trending")
                    elif 'High' in vol_regime or 'Extreme' in vol_regime:
                        scores['volatility'] = 20
                        bearish_reasons.append("High volatility - Reduce position")
                    else:
                        scores['volatility'] = 50

            except Exception as e:
                logger.warning(f"Volatility detection failed: {e}")

        # 3. OI Trap Detection
        if self.oi_trap_detector and option_chain and spot_price:
            try:
                oi_result = self.oi_trap_detector.detect(option_chain, spot_price)

                if hasattr(oi_result, 'trap_detected') and oi_result.trap_detected:
                    trap_type = getattr(oi_result, 'trap_type', 'Unknown')
                    trap_warning = f"{trap_type} detected!"

                    if trap_type == 'BEAR_TRAP':
                        scores['oi_trap'] = 50  # Bullish
                        bullish_reasons.append(f"Bear trap detected - Expect reversal up")
                    elif trap_type == 'BULL_TRAP':
                        scores['oi_trap'] = -50  # Bearish
                        bearish_reasons.append(f"Bull trap detected - Expect reversal down")
                else:
                    trap_warning = "No trap"

            except Exception as e:
                logger.warning(f"OI Trap detection failed: {e}")

        # 4. CVD Analysis
        if self.cvd_analyzer:
            try:
                cvd_result = self.cvd_analyzer.analyze(df)

                if hasattr(cvd_result, 'bias'):
                    if cvd_result.bias == 'Bullish':
                        scores['cvd'] = min(getattr(cvd_result, 'strength', 50), 100)
                        bullish_reasons.append(f"CVD Bullish (Strength: {scores['cvd']:.0f}%)")
                    elif cvd_result.bias == 'Bearish':
                        scores['cvd'] = -min(getattr(cvd_result, 'strength', 50), 100)
                        bearish_reasons.append(f"CVD Bearish (Strength: {abs(scores['cvd']):.0f}%)")

            except Exception as e:
                logger.warning(f"CVD analysis failed: {e}")

        # 5. Liquidity Analysis
        if self.liquidity_analyzer and option_chain and spot_price:
            try:
                liq_result = self.liquidity_analyzer.analyze(option_chain, spot_price)

                if hasattr(liq_result, 'gravity_center'):
                    gravity = liq_result.gravity_center
                    if gravity > spot_price:
                        scores['liquidity'] = 30  # Price likely to move up
                        bullish_reasons.append(f"Liquidity center above price (â‚¹{gravity:,.0f})")
                    elif gravity < spot_price:
                        scores['liquidity'] = -30  # Price likely to move down
                        bearish_reasons.append(f"Liquidity center below price (â‚¹{gravity:,.0f})")

            except Exception as e:
                logger.warning(f"Liquidity analysis failed: {e}")

        # 6. Institutional Flow
        if self.institutional_detector:
            try:
                inst_result = self.institutional_detector.detect(df)

                if hasattr(inst_result, 'dominant_participant'):
                    participant = str(inst_result.dominant_participant)
                    if 'Institutional' in participant:
                        # Follow institutional money
                        if hasattr(inst_result, 'institutional_bias'):
                            if inst_result.institutional_bias == 'Bullish':
                                scores['institutional'] = 40
                                bullish_reasons.append("Institutional buying detected")
                            elif inst_result.institutional_bias == 'Bearish':
                                scores['institutional'] = -40
                                bearish_reasons.append("Institutional selling detected")

            except Exception as e:
                logger.warning(f"Institutional detection failed: {e}")

        # 7. XGBoost Prediction (if model is trained)
        if self.xgboost_analyzer and hasattr(self.xgboost_analyzer, 'is_trained') and self.xgboost_analyzer.is_trained:
            try:
                xgb_result = self.xgboost_analyzer.predict(df, bias_results, option_chain)

                if hasattr(xgb_result, 'prediction'):
                    if xgb_result.prediction == 'BUY':
                        scores['xgboost'] = xgb_result.confidence
                        bullish_reasons.append(f"XGBoost: BUY ({xgb_result.confidence:.0f}%)")
                    elif xgb_result.prediction == 'SELL':
                        scores['xgboost'] = -xgb_result.confidence
                        bearish_reasons.append(f"XGBoost: SELL ({xgb_result.confidence:.0f}%)")

            except Exception as e:
                logger.warning(f"XGBoost prediction failed: {e}")

        # 8. ALL-DAY SPIKE DETECTION (from NIFTY Option Screener)
        # This overrides range-bound signals when high probability spikes are detected
        scores['spike'] = 0
        spike_detected = False
        spike_direction = None
        spike_probability = 0

        try:
            # Get spike data from session state (set by NIFTY Option Screener)
            if 'all_day_spike_result' in st.session_state and st.session_state.all_day_spike_result:
                spike_result = st.session_state.all_day_spike_result

                # Check for active spikes
                active_spikes = spike_result.get('active_spikes', [])
                overall_spike_prob = spike_result.get('overall_spike_probability', 0)
                dominant_direction = spike_result.get('dominant_direction', 'NEUTRAL')

                if active_spikes and overall_spike_prob > 40:
                    spike_detected = True
                    spike_probability = overall_spike_prob

                    # Get highest probability spike
                    best_spike = max(active_spikes, key=lambda x: x.get('probability', 0))
                    spike_type = best_spike.get('type', 'Unknown')
                    spike_prob = best_spike.get('probability', 0)
                    spike_dir = best_spike.get('direction', dominant_direction)

                    # Score based on direction
                    if spike_dir == 'UP' or spike_dir == 'BULLISH':
                        scores['spike'] = min(spike_prob * 1.2, 100)
                        spike_direction = 'UP'
                        bullish_reasons.append(f"ğŸš€ {spike_type} Spike: {spike_prob:.0f}% - Expect UP move")
                    elif spike_dir == 'DOWN' or spike_dir == 'BEARISH':
                        scores['spike'] = -min(spike_prob * 1.2, 100)
                        spike_direction = 'DOWN'
                        bearish_reasons.append(f"ğŸ“‰ {spike_type} Spike: {spike_prob:.0f}% - Expect DOWN move")

                    # If spike probability is very high (>70%), override regime
                    if spike_prob > 70:
                        if spike_direction == 'UP':
                            regime_name = f"SPIKE UP ({spike_prob:.0f}%)"
                            strategy = f"Buy {spike_type} - High probability UP spike"
                        else:
                            regime_name = f"SPIKE DOWN ({spike_prob:.0f}%)"
                            strategy = f"Sell {spike_type} - High probability DOWN spike"

                # Check support/resistance spikes
                support_spike = spike_result.get('support_spike', {})
                resistance_spike = spike_result.get('resistance_spike', {})

                if support_spike and support_spike.get('probability', 0) > 50:
                    supp_prob = support_spike['probability']
                    scores['spike'] += min(supp_prob * 0.5, 40)
                    bullish_reasons.append(f"ğŸ›¡ï¸ Support Spike: {supp_prob:.0f}% at â‚¹{support_spike.get('level', 0):,.0f}")

                if resistance_spike and resistance_spike.get('probability', 0) > 50:
                    res_prob = resistance_spike['probability']
                    scores['spike'] -= min(res_prob * 0.5, 40)
                    bearish_reasons.append(f"ğŸ§± Resistance Spike: {res_prob:.0f}% at â‚¹{resistance_spike.get('level', 0):,.0f}")

        except Exception as e:
            logger.warning(f"Spike detection integration failed: {e}")

        # Calculate weighted final score
        weights = {
            'regime': 0.20,      # 20% (reduced to make room for spike)
            'xgboost': 0.15,     # 15% (if trained)
            'volatility': 0.10,  # 10%
            'oi_trap': 0.15,     # 15%
            'cvd': 0.10,         # 10%
            'liquidity': 0.10,   # 10%
            'institutional': 0.05,  # 5%
            'spike': 0.15        # 15% - NEW spike detection weight
        }

        # Adjust weights if XGBoost not trained
        if not (self.xgboost_analyzer and getattr(self.xgboost_analyzer, 'is_trained', False)):
            weights['xgboost'] = 0
            weights['regime'] = 0.25
            weights['oi_trap'] = 0.20
            weights['cvd'] = 0.15
            weights['spike'] = 0.20  # Increase spike weight when XGBoost not available

        # If high probability spike detected, boost spike weight significantly
        if spike_detected and spike_probability > 60:
            weights['spike'] = 0.30  # 30% weight for strong spikes
            weights['regime'] = 0.15  # Reduce regime weight

        # Normalize weights
        total_weight = sum(weights.values())
        if total_weight > 0:
            weights = {k: v / total_weight for k, v in weights.items()}

        # Calculate final score (only use keys that exist in both scores and weights)
        final_score = sum(scores.get(k, 0) * weights.get(k, 0) for k in weights.keys())

        # BOOST: If spike is detected with high probability, amplify the signal
        if spike_detected and spike_probability > 50:
            if spike_direction == 'UP':
                final_score += spike_probability * 0.5  # Add up to 50 points
            elif spike_direction == 'DOWN':
                final_score -= spike_probability * 0.5  # Subtract up to 50 points

        # BOOST: Use ATM Bias from session state to influence signal
        try:
            if 'overall_option_data' in st.session_state:
                option_data = st.session_state.get('overall_option_data', {}).get('NIFTY', {})
                atm_bias_data = option_data.get('atm_bias', {})
                atm_verdict = atm_bias_data.get('verdict', 'NEUTRAL')
                atm_score = atm_bias_data.get('score', 0)

                if atm_verdict == 'BULLISH' or atm_score > 0.3:
                    final_score += 15
                    if 'ATM Bias Bullish' not in [r for r in bullish_reasons]:
                        bullish_reasons.append(f"ATM Bias: {atm_verdict} ({atm_score:.2f})")
                elif atm_verdict == 'BEARISH' or atm_score < -0.3:
                    final_score -= 15
                    if 'ATM Bias Bearish' not in [r for r in bearish_reasons]:
                        bearish_reasons.append(f"ATM Bias: {atm_verdict} ({atm_score:.2f})")

                # Use seller bias
                seller_bias = option_data.get('seller_bias', 'NEUTRAL')
                if seller_bias == 'BULLISH':
                    final_score += 10
                    bullish_reasons.append("Sellers favor BULLISH")
                elif seller_bias == 'BEARISH':
                    final_score -= 10
                    bearish_reasons.append("Sellers favor BEARISH")
        except Exception:
            pass

        # Determine signal with LOWER thresholds for more responsiveness
        if final_score >= 35:
            signal = "STRONG BUY"
        elif final_score >= 15:
            signal = "BUY"
        elif final_score <= -35:
            signal = "STRONG SELL"
        elif final_score <= -15:
            signal = "SELL"
        else:
            signal = "HOLD"

        # OVERRIDE: High probability spike forces signal even in "HOLD" range
        if spike_detected and spike_probability > 60 and signal == "HOLD":
            if spike_direction == 'UP':
                signal = "BUY"
                bullish_reasons.append(f"âš¡ Spike Override: {spike_probability:.0f}% UP probability")
            elif spike_direction == 'DOWN':
                signal = "SELL"
                bearish_reasons.append(f"âš¡ Spike Override: {spike_probability:.0f}% DOWN probability")

        # Calculate confidence
        confidence = min(abs(final_score) + 50, 100)

        # Determine risk level based on volatility
        if scores['volatility'] >= 70:
            risk_level = "LOW"
            position_multiplier = 1.5
        elif scores['volatility'] >= 40:
            risk_level = "MEDIUM"
            position_multiplier = 1.0
        elif scores['volatility'] >= 20:
            risk_level = "HIGH"
            position_multiplier = 0.5
        else:
            risk_level = "EXTREME"
            position_multiplier = 0.25

        # Calculate entry/exit levels
        current_price = spot_price or (df['Close'].iloc[-1] if 'Close' in df.columns else df['close'].iloc[-1])
        # Handle both 'High'/'high' and 'Low'/'low' column names
        if 'ATR' in df.columns:
            atr = df['ATR'].iloc[-1]
        else:
            high_col = 'High' if 'High' in df.columns else 'high' if 'high' in df.columns else None
            low_col = 'Low' if 'Low' in df.columns else 'low' if 'low' in df.columns else None
            if high_col and low_col:
                atr = df[high_col].iloc[-1] - df[low_col].iloc[-1]
            else:
                atr = 50  # Default ATR if columns missing

        if 'BUY' in signal:
            entry_zone = (current_price - atr * 0.5, current_price)
            stop_loss = current_price - atr * 2
            targets = [
                current_price + atr * 1.5,
                current_price + atr * 3,
                current_price + atr * 5
            ]
        elif 'SELL' in signal:
            entry_zone = (current_price, current_price + atr * 0.5)
            stop_loss = current_price + atr * 2
            targets = [
                current_price - atr * 1.5,
                current_price - atr * 3,
                current_price - atr * 5
            ]
        else:
            entry_zone = (current_price - atr, current_price + atr)
            stop_loss = 0
            targets = []

        # Get expiry data from session state if available
        expiry_data = {}
        days_to_expiry = 7.0
        expiry_spike_prob = 0.0
        expiry_spike_type = "None"
        expiry_warning = "Normal"

        try:
            if 'expiry_spike_data' in st.session_state:
                expiry_data = st.session_state.expiry_spike_data
                # Ensure expiry_data is a dict before calling .get()
                if expiry_data and isinstance(expiry_data, dict):
                    days_to_expiry = expiry_data.get('days_to_expiry', 7.0)
                    expiry_spike_prob = expiry_data.get('probability', 0.0)
                    expiry_spike_type = expiry_data.get('type', 'None')

                if expiry_spike_prob > 60:
                    expiry_warning = f"âš ï¸ HIGH RISK ({expiry_spike_prob:.0f}%)"
                    bearish_reasons.append(f"Expiry spike risk: {expiry_spike_prob:.0f}%")
                elif expiry_spike_prob > 40:
                    expiry_warning = f"MODERATE ({expiry_spike_prob:.0f}%)"
                elif days_to_expiry <= 2:
                    expiry_warning = f"EXPIRY DAY ({days_to_expiry:.1f}d)"
        except:
            pass

        # Expiry score (higher = riskier)
        scores['expiry'] = min(expiry_spike_prob, 100)

        # Get ATM option LTP from session state
        atm_strike_val = 0.0
        atm_call_ltp = 0.0
        atm_put_ltp = 0.0
        try:
            if 'merged_df' in st.session_state and st.session_state.merged_df is not None:
                merged_df = st.session_state.merged_df
                if 'atm_strike' in st.session_state:
                    atm_strike_val = st.session_state.atm_strike
                elif spot_price:
                    # Calculate ATM strike from spot price
                    if 'strikePrice' in merged_df.columns:
                        atm_strike_val = min(merged_df['strikePrice'].tolist(), key=lambda x: abs(x - spot_price))

                if atm_strike_val > 0:
                    atm_row = merged_df[merged_df['strikePrice'] == atm_strike_val]
                    if not atm_row.empty:
                        atm_call_ltp = float(atm_row['LTP_CE'].iloc[0]) if 'LTP_CE' in atm_row.columns else 0.0
                        atm_put_ltp = float(atm_row['LTP_PE'].iloc[0]) if 'LTP_PE' in atm_row.columns else 0.0
        except Exception as e:
            logger.debug(f"Could not fetch ATM LTP: {e}")

        return UnifiedSignal(
            signal=signal,
            confidence=confidence,
            regime_score=scores['regime'],
            xgboost_score=scores['xgboost'],
            volatility_score=scores['volatility'],
            oi_trap_score=scores['oi_trap'],
            cvd_score=scores['cvd'],
            liquidity_score=scores['liquidity'],
            expiry_score=scores['expiry'],
            regime=regime_name,
            volatility_state=volatility_state,
            trap_warning=trap_warning,
            recommended_strategy=strategy,
            days_to_expiry=days_to_expiry,
            expiry_spike_probability=expiry_spike_prob,
            expiry_spike_type=expiry_spike_type,
            expiry_warning=expiry_warning,
            risk_level=risk_level,
            position_size_multiplier=position_multiplier,
            entry_zone=entry_zone,
            stop_loss=stop_loss,
            targets=targets,
            bullish_reasons=bullish_reasons,
            bearish_reasons=bearish_reasons,
            atm_strike=atm_strike_val,
            atm_call_ltp=atm_call_ltp,
            atm_put_ltp=atm_put_ltp,
            timestamp=datetime.now()
        )


def render_unified_signal(signal: UnifiedSignal, spot_price: float = None):
    """
    Render the unified signal in Streamlit
    """
    # Signal color
    signal_colors = {
        'STRONG BUY': '#00FF00',
        'BUY': '#90EE90',
        'HOLD': '#FFD700',
        'SELL': '#FFA500',
        'STRONG SELL': '#FF0000'
    }
    color = signal_colors.get(signal.signal, '#808080')

    # Main signal box
    st.markdown(f"""
    <div style="background: linear-gradient(135deg, {color}22, {color}44);
                border: 3px solid {color};
                border-radius: 15px;
                padding: 25px;
                text-align: center;
                margin-bottom: 20px;">
        <h1 style="color: {color}; margin: 0; font-size: 2.5rem;">ğŸ¯ {signal.signal}</h1>
        <p style="color: #AAA; margin: 10px 0 0 0; font-size: 1.2rem;">
            Confidence: {signal.confidence:.0f}% | Risk: {signal.risk_level}
        </p>
    </div>
    """, unsafe_allow_html=True)

    # Show Spike Detector Status
    spike_data = st.session_state.get('all_day_spike_result', {})
    if spike_data:
        primary_spike = spike_data.get('primary_spike', {})
        spike_prob = primary_spike.get('probability', 0)
        spike_type = primary_spike.get('type', 'None').replace('_', ' ').title()
        spike_dir = primary_spike.get('direction', 'NEUTRAL')
        active_count = spike_data.get('active_spike_count', 0)

        if spike_prob > 0:
            spike_color = "#00ff00" if spike_dir == "UP" else "#ff4444" if spike_dir == "DOWN" else "#ffaa00"
            spike_emoji = "ğŸš€" if spike_dir == "UP" else "ğŸ“‰" if spike_dir == "DOWN" else "â†”ï¸"

            st.markdown(f"""
            <div style="background: linear-gradient(135deg, {spike_color}15, {spike_color}30);
                        border: 1px solid {spike_color};
                        border-radius: 8px;
                        padding: 10px 15px;
                        margin-bottom: 15px;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <span style="color: {spike_color}; font-weight: 700;">{spike_emoji} SPIKE: {spike_type}</span>
                        <span style="color: #888; margin-left: 10px;">({active_count} active)</span>
                    </div>
                    <div style="text-align: right;">
                        <span style="color: {spike_color}; font-size: 1.3rem; font-weight: 900;">{spike_prob:.0f}%</span>
                        <span style="color: #888; margin-left: 5px;">{spike_dir}</span>
                    </div>
                </div>
            </div>
            """, unsafe_allow_html=True)
    else:
        st.caption("ğŸ’¡ Visit NIFTY Option Screener tab to activate spike detection")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ“Š ML MARKET REGIME ASSESSMENT
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    try:
        regime_data = st.session_state.get('ml_regime_result', {})
        if regime_data:
            regime = regime_data.get('regime', 'Unknown')
            confidence = regime_data.get('confidence', 0)
            trend_strength = regime_data.get('trend_strength', 0)
            volatility_state = regime_data.get('volatility_state', 'Normal')
            market_phase = regime_data.get('market_phase', 'Unknown')
            recommended_strategy = regime_data.get('recommended_strategy', '')
            optimal_timeframe = regime_data.get('optimal_timeframe', 'Intraday')
            signals = regime_data.get('signals', [])
            trading_sentiment = regime_data.get('trading_sentiment', 'NEUTRAL')
            sentiment_score = regime_data.get('sentiment_score', 0)
            support_resistance = regime_data.get('support_resistance', {})
            entry_exit = regime_data.get('entry_exit_signals', {})

            # Regime color
            if 'Up' in regime or 'Bullish' in regime:
                regime_color = "#00ff00"
                regime_emoji = "ğŸ‚"
            elif 'Down' in regime or 'Bearish' in regime:
                regime_color = "#ff4444"
                regime_emoji = "ğŸ»"
            elif 'Breakout' in regime:
                regime_color = "#ffa500"
                regime_emoji = "ğŸš€"
            else:
                regime_color = "#ffaa00"
                regime_emoji = "â†”ï¸"

            # Sentiment color
            if 'LONG' in trading_sentiment:
                sent_color = "#00ff00"
            elif 'SHORT' in trading_sentiment:
                sent_color = "#ff4444"
            else:
                sent_color = "#ffaa00"

            # Market phase explanation
            phase_explanations = {
                'Accumulation': "Smart money buying. Expect upward breakout soon.",
                'Markup': "Trending up. Follow the momentum, buy dips.",
                'Distribution': "Smart money selling. Expect downward breakdown.",
                'Markdown': "Trending down. Sell rallies, avoid longs.",
                'Consolidation': "Range-bound. Trade the range or wait for breakout."
            }
            phase_explanation = phase_explanations.get(market_phase, "Market in transition phase.")

            # Support/Resistance
            support = support_resistance.get('near_support', support_resistance.get('major_support', 0)) if support_resistance else 0
            resistance = support_resistance.get('near_resistance', support_resistance.get('major_resistance', 0)) if support_resistance else 0

            # Build signals text
            signals_text = ""
            if signals:
                for sig in signals[:4]:  # Show max 4 signals
                    sig_color = "#00ff00" if "bull" in sig.lower() or "buy" in sig.lower() or "up" in sig.lower() else "#ff4444" if "bear" in sig.lower() or "sell" in sig.lower() or "down" in sig.lower() else "#aaa"
                    signals_text += f'<span style="color: {sig_color};">â€¢ {sig}</span><br>'

            st.markdown(f"""
            <div style="background: linear-gradient(135deg, #1a1a2e, #16213e);
                        border: 1px solid #0f3460;
                        border-radius: 10px;
                        padding: 15px;
                        margin: 15px 0;">
                <h4 style="color: #e94560; margin: 0 0 10px 0;">ğŸ“Š ML MARKET REGIME ASSESSMENT</h4>

                <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                    <div>
                        <span style="color: #888;">Regime:</span>
                        <span style="color: {regime_color}; font-weight: 700; font-size: 1.2rem;"> {regime_emoji} {regime}</span>
                    </div>
                    <div>
                        <span style="color: #888;">Confidence:</span>
                        <span style="color: {regime_color}; font-weight: 700;"> {confidence:.0f}%</span>
                    </div>
                </div>

                <p style="color: #eee; margin: 8px 0;">
                    <strong style="color: #00d9ff;">Market Phase:</strong> {market_phase}
                </p>
                <p style="color: #ffd700; margin: 8px 0;">
                    <strong>What this means:</strong> {phase_explanation}
                </p>

                <p style="color: #aaa; margin: 8px 0;">
                    <strong>Trading Sentiment:</strong>
                    <span style="color: {sent_color}; font-weight: 700;"> {trading_sentiment}</span>
                    <span style="color: #888;"> (Score: {sentiment_score:+.0f})</span>
                </p>

                <p style="color: #aaa; margin: 8px 0;">
                    <strong>Trend Strength:</strong> {trend_strength:.0f}% |
                    <strong>Volatility:</strong> {volatility_state} |
                    <strong>Timeframe:</strong> {optimal_timeframe}
                </p>

                <p style="color: #aaa; margin: 8px 0;">
                    <strong>Recommended Strategy:</strong>
                    <span style="color: #00d9ff;"> {recommended_strategy}</span>
                </p>

                {f'<div style="margin: 10px 0;"><strong style="color: #aaa;">Key Levels:</strong> <span style="color: #00ff00;">Support: â‚¹{support:,.0f}</span> | <span style="color: #ff4444;">Resistance: â‚¹{resistance:,.0f}</span></div>' if support > 0 or resistance > 0 else ''}

                {f'<div style="margin-top: 10px;"><strong style="color: #aaa;">Signals:</strong><br>{signals_text}</div>' if signals_text else ''}
            </div>
            """, unsafe_allow_html=True)
    except Exception as e:
        logger.debug(f"Regime display error: {e}")

    # Show ATM Option Recommendation based on signal
    if signal.signal in ['STRONG BUY', 'BUY'] and signal.atm_call_ltp > 0:
        st.markdown(f"""
        <div style="background: linear-gradient(135deg, #00FF0022, #00FF0044);
                    border: 2px solid #00FF00;
                    border-radius: 10px;
                    padding: 15px;
                    text-align: center;
                    margin-bottom: 15px;">
            <h3 style="color: #00FF00; margin: 0;">ğŸ“ˆ BUY ATM CALL @ â‚¹{signal.atm_strike:,.0f}</h3>
            <p style="color: #90EE90; margin: 5px 0 0 0; font-size: 1.5rem; font-weight: bold;">
                LTP: â‚¹{signal.atm_call_ltp:,.2f}
            </p>
        </div>
        """, unsafe_allow_html=True)
    elif signal.signal in ['STRONG SELL', 'SELL'] and signal.atm_put_ltp > 0:
        st.markdown(f"""
        <div style="background: linear-gradient(135deg, #FF000022, #FF000044);
                    border: 2px solid #FF0000;
                    border-radius: 10px;
                    padding: 15px;
                    text-align: center;
                    margin-bottom: 15px;">
            <h3 style="color: #FF6347; margin: 0;">ğŸ“‰ BUY ATM PUT @ â‚¹{signal.atm_strike:,.0f}</h3>
            <p style="color: #FFA07A; margin: 5px 0 0 0; font-size: 1.5rem; font-weight: bold;">
                LTP: â‚¹{signal.atm_put_ltp:,.2f}
            </p>
        </div>
        """, unsafe_allow_html=True)

    # Send to Telegram for BUY/SELL signals (with auto-send option)
    if signal.signal in ['STRONG BUY', 'BUY', 'STRONG SELL', 'SELL']:
        tg_col1, tg_col2 = st.columns([3, 1])
        with tg_col1:
            auto_send = st.checkbox("ğŸ“± Auto-send to Telegram", value=True, key="ml_signal_auto_telegram")
        with tg_col2:
            manual_send = st.button("ğŸ“¤ Send Now", key="ml_signal_manual_telegram")

        # Auto-send or manual send
        if auto_send or manual_send:
            success, msg = send_ml_signal_telegram(signal, spot_price)
            if success:
                st.success(f"âœ… {msg}")
            elif "already sent" not in msg.lower() and "not configured" not in msg.lower():
                st.warning(f"âš ï¸ {msg}")

    # Metrics row 1
    col1, col2, col3, col4, col5, col6 = st.columns(6)

    with col1:
        st.metric("Regime", signal.regime, f"{signal.regime_score:+.0f}")

    with col2:
        st.metric("Volatility", signal.volatility_state, f"{signal.volatility_score:.0f}%")

    with col3:
        st.metric("OI Trap", signal.trap_warning[:12], f"{signal.oi_trap_score:+.0f}")

    with col4:
        st.metric("CVD", f"{signal.cvd_score:+.0f}", "Bull" if signal.cvd_score > 0 else "Bear" if signal.cvd_score < 0 else "-")

    with col5:
        st.metric("Expiry", f"{signal.days_to_expiry:.1f}d", signal.expiry_warning[:10])

    with col6:
        st.metric("Position", f"{signal.position_size_multiplier:.1f}x", signal.risk_level)

    st.divider()

    # Strategy recommendation
    st.info(f"ğŸ“Š **Strategy:** {signal.recommended_strategy}")

    # Entry/Exit levels
    if signal.signal != "HOLD" and spot_price:
        col1, col2 = st.columns(2)

        with col1:
            st.markdown("### ğŸ¯ Entry Zone")
            st.write(f"**Entry:** â‚¹{signal.entry_zone[0]:,.0f} - â‚¹{signal.entry_zone[1]:,.0f}")
            st.write(f"**Stop Loss:** â‚¹{signal.stop_loss:,.0f}")

        with col2:
            st.markdown("### ğŸ¯ Targets")
            for i, target in enumerate(signal.targets, 1):
                st.write(f"**T{i}:** â‚¹{target:,.0f}")

    # Reasons
    col1, col2 = st.columns(2)

    with col1:
        if signal.bullish_reasons:
            st.markdown("### ğŸ‚ Bullish Signals")
            for reason in signal.bullish_reasons:
                st.success(f"âœ… {reason}")

    with col2:
        if signal.bearish_reasons:
            st.markdown("### ğŸ» Bearish Signals")
            for reason in signal.bearish_reasons:
                st.error(f"âš ï¸ {reason}")

    # Component scores chart
    with st.expander("ğŸ“Š Component Scores Breakdown"):
        scores_df = pd.DataFrame({
            'Component': ['Regime', 'XGBoost', 'Volatility', 'OI Trap', 'CVD', 'Liquidity'],
            'Score': [
                signal.regime_score,
                signal.xgboost_score,
                signal.volatility_score - 50,  # Normalize to -50 to +50
                signal.oi_trap_score,
                signal.cvd_score,
                signal.liquidity_score
            ]
        })

        import plotly.express as px
        fig = px.bar(
            scores_df,
            x='Component',
            y='Score',
            color='Score',
            color_continuous_scale=['red', 'yellow', 'green'],
            range_color=[-100, 100]
        )
        fig.update_layout(height=300)
        st.plotly_chart(fig, use_container_width=True)


def get_cached_unified_signal() -> Optional[UnifiedSignal]:
    """Get cached unified signal from session state"""
    return st.session_state.get('unified_ml_signal')
