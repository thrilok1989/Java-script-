"""
Unified ML Trading Signal
==========================
Combines ALL ML modules into a SINGLE trading signal

Modules Combined:
1. ML Market Regime Detection
2. XGBoost Prediction (BUY/SELL/HOLD)
3. Volatility Regime
4. OI Trap Detection
5. CVD Delta Imbalance
6. Liquidity Gravity Analysis
7. Institutional vs Retail Detection

Output: Single unified trading signal with confidence score
"""

import streamlit as st
import pandas as pd
import numpy as np
import requests
from datetime import datetime
from typing import Dict, Any, Optional, Tuple
from dataclasses import dataclass
import logging

logger = logging.getLogger(__name__)


def send_ml_signal_telegram(signal, spot_price: float = None):
    """
    Send ML Signal to Telegram when BUY/SELL signal is generated
    """
    try:
        # Get Telegram credentials from secrets
        bot_token = st.secrets.get("TELEGRAM_BOT_TOKEN", "")
        chat_id = st.secrets.get("TELEGRAM_CHAT_ID", "")

        if not bot_token or not chat_id:
            return False, "Telegram not configured"

        # Check if we already sent this signal (avoid duplicates)
        signal_key = f"{signal.signal}_{signal.atm_strike}_{signal.timestamp.strftime('%Y%m%d%H%M')}"
        if 'last_ml_telegram_signal' in st.session_state:
            if st.session_state.last_ml_telegram_signal == signal_key:
                return False, "Signal already sent"

        # Build the message
        if signal.signal in ['STRONG BUY', 'BUY']:
            emoji = "ğŸŸ¢ğŸ“ˆ"
            option_type = "CALL"
            option_ltp = signal.atm_call_ltp
        elif signal.signal in ['STRONG SELL', 'SELL']:
            emoji = "ğŸ”´ğŸ“‰"
            option_type = "PUT"
            option_ltp = signal.atm_put_ltp
        else:
            return False, "No actionable signal"

        # Format targets
        targets_str = ""
        if signal.targets:
            for i, t in enumerate(signal.targets, 1):
                targets_str += f"T{i}: â‚¹{t:,.0f}\n"

        # Build message
        message = f"""
{emoji} *ML TRADING SIGNAL* {emoji}

ğŸ¯ *Signal:* {signal.signal}
ğŸ“Š *Confidence:* {signal.confidence:.0f}%
âš ï¸ *Risk Level:* {signal.risk_level}

ğŸ’° *Trade Setup:*
â€¢ ATM Strike: â‚¹{signal.atm_strike:,.0f}
â€¢ Option: BUY {option_type}
â€¢ LTP: â‚¹{option_ltp:,.2f}

ğŸ“ˆ *Strategy:* {signal.recommended_strategy}

ğŸ¯ *Entry Zone:* â‚¹{signal.entry_zone[0]:,.0f} - â‚¹{signal.entry_zone[1]:,.0f}
ğŸ›‘ *Stop Loss:* â‚¹{signal.stop_loss:,.0f}

ğŸ¯ *Targets:*
{targets_str}
ğŸ“Š *Market Regime:* {signal.regime}
ğŸ“‰ *Volatility:* {signal.volatility_state}
â° *Expiry:* {signal.days_to_expiry:.1f} days

âš¡ _Generated by ML Signal Engine_
"""

        # Send to Telegram
        url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
        payload = {
            "chat_id": chat_id,
            "text": message,
            "parse_mode": "Markdown",
            "disable_web_page_preview": True
        }
        response = requests.post(url, json=payload, timeout=10)

        if response.status_code == 200:
            # Store signal key to avoid duplicates
            st.session_state.last_ml_telegram_signal = signal_key
            return True, "Signal sent to Telegram!"
        else:
            return False, f"Failed: {response.status_code}"

    except Exception as e:
        logger.error(f"Telegram send error: {e}")
        return False, f"Error: {str(e)}"


@dataclass
class UnifiedSignal:
    """Unified Trading Signal"""
    signal: str  # "STRONG BUY", "BUY", "HOLD", "SELL", "STRONG SELL"
    confidence: float  # 0-100

    # Component scores
    regime_score: float  # -100 to +100
    xgboost_score: float  # -100 to +100
    volatility_score: float  # 0 to 100
    oi_trap_score: float  # -100 to +100
    cvd_score: float  # -100 to +100
    liquidity_score: float  # -100 to +100
    expiry_score: float  # 0 to 100 (risk score)

    # Details
    regime: str
    volatility_state: str
    trap_warning: str
    recommended_strategy: str

    # Expiry analysis
    days_to_expiry: float
    expiry_spike_probability: float
    expiry_spike_type: str
    expiry_warning: str

    # Risk metrics
    risk_level: str  # "LOW", "MEDIUM", "HIGH", "EXTREME"
    position_size_multiplier: float  # 0.25 to 1.5

    # Entry/Exit levels
    entry_zone: Tuple[float, float]
    stop_loss: float
    targets: list

    # Reasoning
    bullish_reasons: list
    bearish_reasons: list

    # ATM Option LTP for trade recommendation
    atm_strike: float = 0.0
    atm_call_ltp: float = 0.0
    atm_put_ltp: float = 0.0

    timestamp: datetime = None


class UnifiedMLSignalGenerator:
    """
    Generates a unified trading signal from all ML modules
    """

    def __init__(self):
        """Initialize the signal generator"""
        self.modules_loaded = {}
        self._load_modules()

    def _load_modules(self):
        """Load all ML modules"""
        # ML Market Regime
        try:
            from src.ml_market_regime import MLMarketRegimeDetector
            self.regime_detector = MLMarketRegimeDetector()
            self.modules_loaded['regime'] = True
        except ImportError:
            self.modules_loaded['regime'] = False
            self.regime_detector = None

        # XGBoost Analyzer
        try:
            from src.xgboost_ml_analyzer import XGBoostMLAnalyzer
            self.xgboost_analyzer = XGBoostMLAnalyzer()
            self.modules_loaded['xgboost'] = True
        except ImportError:
            self.modules_loaded['xgboost'] = False
            self.xgboost_analyzer = None

        # Volatility Regime
        try:
            from src.volatility_regime import VolatilityRegimeDetector
            self.volatility_detector = VolatilityRegimeDetector()
            self.modules_loaded['volatility'] = True
        except ImportError:
            self.modules_loaded['volatility'] = False
            self.volatility_detector = None

        # OI Trap Detection
        try:
            from src.oi_trap_detection import OITrapDetector
            self.oi_trap_detector = OITrapDetector()
            self.modules_loaded['oi_trap'] = True
        except ImportError:
            self.modules_loaded['oi_trap'] = False
            self.oi_trap_detector = None

        # CVD Analyzer
        try:
            from src.cvd_delta_imbalance import CVDAnalyzer
            self.cvd_analyzer = CVDAnalyzer()
            self.modules_loaded['cvd'] = True
        except ImportError:
            self.modules_loaded['cvd'] = False
            self.cvd_analyzer = None

        # Liquidity Analyzer
        try:
            from src.liquidity_gravity import LiquidityGravityAnalyzer
            self.liquidity_analyzer = LiquidityGravityAnalyzer()
            self.modules_loaded['liquidity'] = True
        except ImportError:
            self.modules_loaded['liquidity'] = False
            self.liquidity_analyzer = None

        # Institutional Detector
        try:
            from src.institutional_retail_detector import InstitutionalRetailDetector
            self.institutional_detector = InstitutionalRetailDetector()
            self.modules_loaded['institutional'] = True
        except ImportError:
            self.modules_loaded['institutional'] = False
            self.institutional_detector = None

    def generate_signal(
        self,
        df: pd.DataFrame,
        option_chain: Optional[Dict] = None,
        vix_current: Optional[float] = None,
        spot_price: Optional[float] = None,
        bias_results: Optional[Dict] = None
    ) -> UnifiedSignal:
        """
        Generate unified trading signal from all ML modules

        Args:
            df: Price DataFrame with OHLCV
            option_chain: Option chain data
            vix_current: Current VIX value
            spot_price: Current spot price
            bias_results: Results from Bias Analysis Pro

        Returns:
            UnifiedSignal with combined analysis
        """
        # Initialize scores
        scores = {
            'regime': 0,
            'xgboost': 0,
            'volatility': 50,  # Neutral default
            'oi_trap': 0,
            'cvd': 0,
            'liquidity': 0,
            'institutional': 0
        }

        bullish_reasons = []
        bearish_reasons = []

        regime_name = "Unknown"
        volatility_state = "Normal"
        trap_warning = "None"
        strategy = "Wait for confirmation"

        # Ensure ATR column exists (handle both 'High'/'Low' and 'high'/'low' columns)
        if 'ATR' not in df.columns:
            df = df.copy()
            # Check for column names (could be 'High' or 'high')
            high_col = 'High' if 'High' in df.columns else 'high' if 'high' in df.columns else None
            low_col = 'Low' if 'Low' in df.columns else 'low' if 'low' in df.columns else None
            if high_col and low_col:
                df['ATR'] = df[high_col] - df[low_col]
            else:
                df['ATR'] = 50  # Default ATR if columns missing

        # 1. ML Market Regime
        regime_result = None
        if self.regime_detector:
            try:
                regime_result = self.regime_detector.detect_regime(df)
                regime_name = regime_result.regime

                # Store full regime result in session state for display
                st.session_state['ml_regime_result'] = {
                    'regime': regime_result.regime,
                    'confidence': regime_result.confidence,
                    'trend_strength': regime_result.trend_strength,
                    'volatility_state': regime_result.volatility_state,
                    'market_phase': regime_result.market_phase,
                    'recommended_strategy': regime_result.recommended_strategy,
                    'optimal_timeframe': regime_result.optimal_timeframe,
                    'signals': regime_result.signals if hasattr(regime_result, 'signals') else [],
                    'trading_sentiment': getattr(regime_result, 'trading_sentiment', 'NEUTRAL'),
                    'sentiment_confidence': getattr(regime_result, 'sentiment_confidence', 0),
                    'sentiment_score': getattr(regime_result, 'sentiment_score', 0),
                    'support_resistance': getattr(regime_result, 'support_resistance', {}),
                    'entry_exit_signals': getattr(regime_result, 'entry_exit_signals', {})
                }

                # Convert regime to score (-100 to +100)
                if 'Up' in regime_name or 'BULLISH' in regime_name.upper():
                    scores['regime'] = min(regime_result.trend_strength * 1.5, 100)
                    bullish_reasons.append(f"Regime: {regime_name} (Trend: {regime_result.trend_strength:.0f}%)")
                elif 'Down' in regime_name or 'BEARISH' in regime_name.upper():
                    scores['regime'] = -min(regime_result.trend_strength * 1.5, 100)
                    bearish_reasons.append(f"Regime: {regime_name} (Trend: {regime_result.trend_strength:.0f}%)")
                else:
                    scores['regime'] = 0

                volatility_state = regime_result.volatility_state
                strategy = regime_result.recommended_strategy

            except Exception as e:
                logger.warning(f"Regime detection failed: {e}")

        # 2. Volatility Analysis
        if self.volatility_detector and vix_current:
            try:
                vol_result = self.volatility_detector.detect(df, vix_current)

                # Volatility affects position sizing, not direction
                if hasattr(vol_result, 'regime'):
                    vol_regime = str(vol_result.regime)
                    if 'Low' in vol_regime:
                        scores['volatility'] = 80
                        bullish_reasons.append("Low volatility - Good for trending")
                    elif 'High' in vol_regime or 'Extreme' in vol_regime:
                        scores['volatility'] = 20
                        bearish_reasons.append("High volatility - Reduce position")
                    else:
                        scores['volatility'] = 50

            except Exception as e:
                logger.warning(f"Volatility detection failed: {e}")

        # 3. OI Trap Detection
        if self.oi_trap_detector and option_chain and spot_price:
            try:
                oi_result = self.oi_trap_detector.detect(option_chain, spot_price)

                if hasattr(oi_result, 'trap_detected') and oi_result.trap_detected:
                    trap_type = getattr(oi_result, 'trap_type', 'Unknown')
                    trap_warning = f"{trap_type} detected!"

                    if trap_type == 'BEAR_TRAP':
                        scores['oi_trap'] = 50  # Bullish
                        bullish_reasons.append(f"Bear trap detected - Expect reversal up")
                    elif trap_type == 'BULL_TRAP':
                        scores['oi_trap'] = -50  # Bearish
                        bearish_reasons.append(f"Bull trap detected - Expect reversal down")
                else:
                    trap_warning = "No trap"

            except Exception as e:
                logger.warning(f"OI Trap detection failed: {e}")

        # 4. CVD Analysis
        if self.cvd_analyzer:
            try:
                cvd_result = self.cvd_analyzer.analyze(df)

                if hasattr(cvd_result, 'bias'):
                    if cvd_result.bias == 'Bullish':
                        scores['cvd'] = min(getattr(cvd_result, 'strength', 50), 100)
                        bullish_reasons.append(f"CVD Bullish (Strength: {scores['cvd']:.0f}%)")
                    elif cvd_result.bias == 'Bearish':
                        scores['cvd'] = -min(getattr(cvd_result, 'strength', 50), 100)
                        bearish_reasons.append(f"CVD Bearish (Strength: {abs(scores['cvd']):.0f}%)")

            except Exception as e:
                logger.warning(f"CVD analysis failed: {e}")

        # 5. Liquidity Analysis
        if self.liquidity_analyzer and option_chain and spot_price:
            try:
                liq_result = self.liquidity_analyzer.analyze(option_chain, spot_price)

                if hasattr(liq_result, 'gravity_center'):
                    gravity = liq_result.gravity_center
                    if gravity > spot_price:
                        scores['liquidity'] = 30  # Price likely to move up
                        bullish_reasons.append(f"Liquidity center above price (â‚¹{gravity:,.0f})")
                    elif gravity < spot_price:
                        scores['liquidity'] = -30  # Price likely to move down
                        bearish_reasons.append(f"Liquidity center below price (â‚¹{gravity:,.0f})")

            except Exception as e:
                logger.warning(f"Liquidity analysis failed: {e}")

        # 6. Institutional Flow
        if self.institutional_detector:
            try:
                inst_result = self.institutional_detector.detect(df)

                if hasattr(inst_result, 'dominant_participant'):
                    participant = str(inst_result.dominant_participant)
                    if 'Institutional' in participant:
                        # Follow institutional money
                        if hasattr(inst_result, 'institutional_bias'):
                            if inst_result.institutional_bias == 'Bullish':
                                scores['institutional'] = 40
                                bullish_reasons.append("Institutional buying detected")
                            elif inst_result.institutional_bias == 'Bearish':
                                scores['institutional'] = -40
                                bearish_reasons.append("Institutional selling detected")

            except Exception as e:
                logger.warning(f"Institutional detection failed: {e}")

        # 7. XGBoost Prediction (if model is trained)
        if self.xgboost_analyzer and hasattr(self.xgboost_analyzer, 'is_trained') and self.xgboost_analyzer.is_trained:
            try:
                xgb_result = self.xgboost_analyzer.predict(df, bias_results, option_chain)

                if hasattr(xgb_result, 'prediction'):
                    if xgb_result.prediction == 'BUY':
                        scores['xgboost'] = xgb_result.confidence
                        bullish_reasons.append(f"XGBoost: BUY ({xgb_result.confidence:.0f}%)")
                    elif xgb_result.prediction == 'SELL':
                        scores['xgboost'] = -xgb_result.confidence
                        bearish_reasons.append(f"XGBoost: SELL ({xgb_result.confidence:.0f}%)")

            except Exception as e:
                logger.warning(f"XGBoost prediction failed: {e}")

        # 8. ALL-DAY SPIKE DETECTION (from NIFTY Option Screener)
        # This overrides range-bound signals when high probability spikes are detected
        scores['spike'] = 0
        spike_detected = False
        spike_direction = None
        spike_probability = 0

        try:
            # Get spike data from session state (set by NIFTY Option Screener)
            if 'all_day_spike_result' in st.session_state and st.session_state.all_day_spike_result:
                spike_result = st.session_state.all_day_spike_result

                # Check for active spikes
                active_spikes = spike_result.get('active_spikes', [])
                overall_spike_prob = spike_result.get('overall_spike_probability', 0)
                dominant_direction = spike_result.get('dominant_direction', 'NEUTRAL')

                if active_spikes and overall_spike_prob > 40:
                    spike_detected = True
                    spike_probability = overall_spike_prob

                    # Get highest probability spike
                    best_spike = max(active_spikes, key=lambda x: x.get('probability', 0))
                    spike_type = best_spike.get('type', 'Unknown')
                    spike_prob = best_spike.get('probability', 0)
                    spike_dir = best_spike.get('direction', dominant_direction)

                    # Score based on direction
                    if spike_dir == 'UP' or spike_dir == 'BULLISH':
                        scores['spike'] = min(spike_prob * 1.2, 100)
                        spike_direction = 'UP'
                        bullish_reasons.append(f"ğŸš€ {spike_type} Spike: {spike_prob:.0f}% - Expect UP move")
                    elif spike_dir == 'DOWN' or spike_dir == 'BEARISH':
                        scores['spike'] = -min(spike_prob * 1.2, 100)
                        spike_direction = 'DOWN'
                        bearish_reasons.append(f"ğŸ“‰ {spike_type} Spike: {spike_prob:.0f}% - Expect DOWN move")

                    # If spike probability is very high (>70%), override regime
                    if spike_prob > 70:
                        if spike_direction == 'UP':
                            regime_name = f"SPIKE UP ({spike_prob:.0f}%)"
                            strategy = f"Buy {spike_type} - High probability UP spike"
                        else:
                            regime_name = f"SPIKE DOWN ({spike_prob:.0f}%)"
                            strategy = f"Sell {spike_type} - High probability DOWN spike"

                # Check support/resistance spikes
                support_spike = spike_result.get('support_spike', {})
                resistance_spike = spike_result.get('resistance_spike', {})

                if support_spike and support_spike.get('probability', 0) > 50:
                    supp_prob = support_spike['probability']
                    scores['spike'] += min(supp_prob * 0.5, 40)
                    bullish_reasons.append(f"ğŸ›¡ï¸ Support Spike: {supp_prob:.0f}% at â‚¹{support_spike.get('level', 0):,.0f}")

                if resistance_spike and resistance_spike.get('probability', 0) > 50:
                    res_prob = resistance_spike['probability']
                    scores['spike'] -= min(res_prob * 0.5, 40)
                    bearish_reasons.append(f"ğŸ§± Resistance Spike: {res_prob:.0f}% at â‚¹{resistance_spike.get('level', 0):,.0f}")

        except Exception as e:
            logger.warning(f"Spike detection integration failed: {e}")

        # Calculate weighted final score
        weights = {
            'regime': 0.20,      # 20% (reduced to make room for spike)
            'xgboost': 0.15,     # 15% (if trained)
            'volatility': 0.10,  # 10%
            'oi_trap': 0.15,     # 15%
            'cvd': 0.10,         # 10%
            'liquidity': 0.10,   # 10%
            'institutional': 0.05,  # 5%
            'spike': 0.15        # 15% - NEW spike detection weight
        }

        # Adjust weights if XGBoost not trained
        if not (self.xgboost_analyzer and getattr(self.xgboost_analyzer, 'is_trained', False)):
            weights['xgboost'] = 0
            weights['regime'] = 0.25
            weights['oi_trap'] = 0.20
            weights['cvd'] = 0.15
            weights['spike'] = 0.20  # Increase spike weight when XGBoost not available

        # If high probability spike detected, boost spike weight significantly
        if spike_detected and spike_probability > 60:
            weights['spike'] = 0.30  # 30% weight for strong spikes
            weights['regime'] = 0.15  # Reduce regime weight

        # Normalize weights
        total_weight = sum(weights.values())
        if total_weight > 0:
            weights = {k: v / total_weight for k, v in weights.items()}

        # Calculate final score (only use keys that exist in both scores and weights)
        final_score = sum(scores.get(k, 0) * weights.get(k, 0) for k in weights.keys())

        # BOOST: If spike is detected with high probability, amplify the signal
        if spike_detected and spike_probability > 50:
            if spike_direction == 'UP':
                final_score += spike_probability * 0.5  # Add up to 50 points
            elif spike_direction == 'DOWN':
                final_score -= spike_probability * 0.5  # Subtract up to 50 points

        # BOOST: Use ATM Bias from session state to influence signal
        try:
            if 'overall_option_data' in st.session_state:
                option_data = st.session_state.get('overall_option_data', {}).get('NIFTY', {})
                atm_bias_data = option_data.get('atm_bias', {})
                atm_verdict = atm_bias_data.get('verdict', 'NEUTRAL')
                atm_score = atm_bias_data.get('score', 0)

                if atm_verdict == 'BULLISH' or atm_score > 0.3:
                    final_score += 15
                    if 'ATM Bias Bullish' not in [r for r in bullish_reasons]:
                        bullish_reasons.append(f"ATM Bias: {atm_verdict} ({atm_score:.2f})")
                elif atm_verdict == 'BEARISH' or atm_score < -0.3:
                    final_score -= 15
                    if 'ATM Bias Bearish' not in [r for r in bearish_reasons]:
                        bearish_reasons.append(f"ATM Bias: {atm_verdict} ({atm_score:.2f})")

                # Use seller bias
                seller_bias = option_data.get('seller_bias', 'NEUTRAL')
                if seller_bias == 'BULLISH':
                    final_score += 10
                    bullish_reasons.append("Sellers favor BULLISH")
                elif seller_bias == 'BEARISH':
                    final_score -= 10
                    bearish_reasons.append("Sellers favor BEARISH")
        except Exception:
            pass

        # Determine signal with LOWER thresholds for more responsiveness
        if final_score >= 35:
            signal = "STRONG BUY"
        elif final_score >= 15:
            signal = "BUY"
        elif final_score <= -35:
            signal = "STRONG SELL"
        elif final_score <= -15:
            signal = "SELL"
        else:
            signal = "HOLD"

        # OVERRIDE: High probability spike forces signal even in "HOLD" range
        if spike_detected and spike_probability > 60 and signal == "HOLD":
            if spike_direction == 'UP':
                signal = "BUY"
                bullish_reasons.append(f"âš¡ Spike Override: {spike_probability:.0f}% UP probability")
            elif spike_direction == 'DOWN':
                signal = "SELL"
                bearish_reasons.append(f"âš¡ Spike Override: {spike_probability:.0f}% DOWN probability")

        # Calculate confidence
        confidence = min(abs(final_score) + 50, 100)

        # Determine risk level based on volatility
        if scores['volatility'] >= 70:
            risk_level = "LOW"
            position_multiplier = 1.5
        elif scores['volatility'] >= 40:
            risk_level = "MEDIUM"
            position_multiplier = 1.0
        elif scores['volatility'] >= 20:
            risk_level = "HIGH"
            position_multiplier = 0.5
        else:
            risk_level = "EXTREME"
            position_multiplier = 0.25

        # Calculate entry/exit levels
        current_price = spot_price or (df['Close'].iloc[-1] if 'Close' in df.columns else df['close'].iloc[-1])
        # Handle both 'High'/'high' and 'Low'/'low' column names
        if 'ATR' in df.columns:
            atr = df['ATR'].iloc[-1]
        else:
            high_col = 'High' if 'High' in df.columns else 'high' if 'high' in df.columns else None
            low_col = 'Low' if 'Low' in df.columns else 'low' if 'low' in df.columns else None
            if high_col and low_col:
                atr = df[high_col].iloc[-1] - df[low_col].iloc[-1]
            else:
                atr = 50  # Default ATR if columns missing

        if 'BUY' in signal:
            entry_zone = (current_price - atr * 0.5, current_price)
            stop_loss = current_price - atr * 2
            targets = [
                current_price + atr * 1.5,
                current_price + atr * 3,
                current_price + atr * 5
            ]
        elif 'SELL' in signal:
            entry_zone = (current_price, current_price + atr * 0.5)
            stop_loss = current_price + atr * 2
            targets = [
                current_price - atr * 1.5,
                current_price - atr * 3,
                current_price - atr * 5
            ]
        else:
            entry_zone = (current_price - atr, current_price + atr)
            stop_loss = 0
            targets = []

        # Get expiry data from session state if available
        expiry_data = {}
        days_to_expiry = 7.0
        expiry_spike_prob = 0.0
        expiry_spike_type = "None"
        expiry_warning = "Normal"

        try:
            if 'expiry_spike_data' in st.session_state:
                expiry_data = st.session_state.expiry_spike_data
                # Ensure expiry_data is a dict before calling .get()
                if expiry_data and isinstance(expiry_data, dict):
                    days_to_expiry = expiry_data.get('days_to_expiry', 7.0)
                    expiry_spike_prob = expiry_data.get('probability', 0.0)
                    expiry_spike_type = expiry_data.get('type', 'None')

                if expiry_spike_prob > 60:
                    expiry_warning = f"âš ï¸ HIGH RISK ({expiry_spike_prob:.0f}%)"
                    bearish_reasons.append(f"Expiry spike risk: {expiry_spike_prob:.0f}%")
                elif expiry_spike_prob > 40:
                    expiry_warning = f"MODERATE ({expiry_spike_prob:.0f}%)"
                elif days_to_expiry <= 2:
                    expiry_warning = f"EXPIRY DAY ({days_to_expiry:.1f}d)"
        except:
            pass

        # Expiry score (higher = riskier)
        scores['expiry'] = min(expiry_spike_prob, 100)

        # Get ATM option LTP from session state
        atm_strike_val = 0.0
        atm_call_ltp = 0.0
        atm_put_ltp = 0.0
        try:
            if 'merged_df' in st.session_state and st.session_state.merged_df is not None:
                merged_df = st.session_state.merged_df
                if 'atm_strike' in st.session_state:
                    atm_strike_val = st.session_state.atm_strike
                elif spot_price:
                    # Calculate ATM strike from spot price
                    if 'strikePrice' in merged_df.columns:
                        atm_strike_val = min(merged_df['strikePrice'].tolist(), key=lambda x: abs(x - spot_price))

                if atm_strike_val > 0:
                    atm_row = merged_df[merged_df['strikePrice'] == atm_strike_val]
                    if not atm_row.empty:
                        atm_call_ltp = float(atm_row['LTP_CE'].iloc[0]) if 'LTP_CE' in atm_row.columns else 0.0
                        atm_put_ltp = float(atm_row['LTP_PE'].iloc[0]) if 'LTP_PE' in atm_row.columns else 0.0
        except Exception as e:
            logger.debug(f"Could not fetch ATM LTP: {e}")

        return UnifiedSignal(
            signal=signal,
            confidence=confidence,
            regime_score=scores['regime'],
            xgboost_score=scores['xgboost'],
            volatility_score=scores['volatility'],
            oi_trap_score=scores['oi_trap'],
            cvd_score=scores['cvd'],
            liquidity_score=scores['liquidity'],
            expiry_score=scores['expiry'],
            regime=regime_name,
            volatility_state=volatility_state,
            trap_warning=trap_warning,
            recommended_strategy=strategy,
            days_to_expiry=days_to_expiry,
            expiry_spike_probability=expiry_spike_prob,
            expiry_spike_type=expiry_spike_type,
            expiry_warning=expiry_warning,
            risk_level=risk_level,
            position_size_multiplier=position_multiplier,
            entry_zone=entry_zone,
            stop_loss=stop_loss,
            targets=targets,
            bullish_reasons=bullish_reasons,
            bearish_reasons=bearish_reasons,
            atm_strike=atm_strike_val,
            atm_call_ltp=atm_call_ltp,
            atm_put_ltp=atm_put_ltp,
            timestamp=datetime.now()
        )


def render_unified_signal(signal: UnifiedSignal, spot_price: float = None):
    """
    Render the unified signal in Streamlit
    """
    # Signal color
    signal_colors = {
        'STRONG BUY': '#00FF00',
        'BUY': '#90EE90',
        'HOLD': '#FFD700',
        'SELL': '#FFA500',
        'STRONG SELL': '#FF0000'
    }
    color = signal_colors.get(signal.signal, '#808080')

    # Main signal box
    st.markdown(f"""
    <div style="background: linear-gradient(135deg, {color}22, {color}44);
                border: 3px solid {color};
                border-radius: 15px;
                padding: 25px;
                text-align: center;
                margin-bottom: 20px;">
        <h1 style="color: {color}; margin: 0; font-size: 2.5rem;">ğŸ¯ {signal.signal}</h1>
        <p style="color: #AAA; margin: 10px 0 0 0; font-size: 1.2rem;">
            Confidence: {signal.confidence:.0f}% | Risk: {signal.risk_level}
        </p>
    </div>
    """, unsafe_allow_html=True)

    # Show Spike Detector Status
    spike_data = st.session_state.get('all_day_spike_result', {})
    if spike_data:
        primary_spike = spike_data.get('primary_spike', {})
        spike_prob = primary_spike.get('probability', 0)
        spike_type = primary_spike.get('type', 'None').replace('_', ' ').title()
        spike_dir = primary_spike.get('direction', 'NEUTRAL')
        active_count = spike_data.get('active_spike_count', 0)

        if spike_prob > 0:
            spike_color = "#00ff00" if spike_dir == "UP" else "#ff4444" if spike_dir == "DOWN" else "#ffaa00"
            spike_emoji = "ğŸš€" if spike_dir == "UP" else "ğŸ“‰" if spike_dir == "DOWN" else "â†”ï¸"

            st.markdown(f"""
            <div style="background: linear-gradient(135deg, {spike_color}15, {spike_color}30);
                        border: 1px solid {spike_color};
                        border-radius: 8px;
                        padding: 10px 15px;
                        margin-bottom: 15px;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <span style="color: {spike_color}; font-weight: 700;">{spike_emoji} SPIKE: {spike_type}</span>
                        <span style="color: #888; margin-left: 10px;">({active_count} active)</span>
                    </div>
                    <div style="text-align: right;">
                        <span style="color: {spike_color}; font-size: 1.3rem; font-weight: 900;">{spike_prob:.0f}%</span>
                        <span style="color: #888; margin-left: 5px;">{spike_dir}</span>
                    </div>
                </div>
            </div>
            """, unsafe_allow_html=True)
    else:
        st.caption("ğŸ’¡ Visit NIFTY Option Screener tab to activate spike detection")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ“Š ML MARKET REGIME ASSESSMENT
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Always show regime info using signal data
    regime_data = st.session_state.get('ml_regime_result', {})

    # Use signal data as fallback
    regime = regime_data.get('regime', signal.regime) if regime_data else signal.regime
    confidence = regime_data.get('confidence', signal.confidence) if regime_data else signal.confidence
    trend_strength = regime_data.get('trend_strength', 50) if regime_data else 50
    volatility_state = regime_data.get('volatility_state', signal.volatility_state) if regime_data else signal.volatility_state
    market_phase = regime_data.get('market_phase', 'Unknown') if regime_data else 'Unknown'
    recommended_strategy = regime_data.get('recommended_strategy', signal.recommended_strategy) if regime_data else signal.recommended_strategy
    optimal_timeframe = regime_data.get('optimal_timeframe', 'Intraday') if regime_data else 'Intraday'
    signals_list = regime_data.get('signals', []) if regime_data else []
    trading_sentiment = regime_data.get('trading_sentiment', 'NEUTRAL') if regime_data else 'NEUTRAL'
    sentiment_score = regime_data.get('sentiment_score', 0) if regime_data else 0
    support_resistance = regime_data.get('support_resistance', {}) if regime_data else {}

    # Determine market phase from regime if not available
    if market_phase == 'Unknown':
        if 'Up' in regime or 'Bullish' in regime.upper() if regime else False:
            market_phase = 'Markup'
        elif 'Down' in regime or 'Bearish' in regime.upper() if regime else False:
            market_phase = 'Markdown'
        elif 'Range' in regime or 'Consolidation' in regime if regime else False:
            market_phase = 'Consolidation'
        elif 'Breakout' in regime if regime else False:
            market_phase = 'Breakout'

    # Regime color
    if regime and ('Up' in regime or 'Bullish' in str(regime).upper()):
        regime_color = "#00ff00"
        regime_emoji = "ğŸ‚"
    elif regime and ('Down' in regime or 'Bearish' in str(regime).upper()):
        regime_color = "#ff4444"
        regime_emoji = "ğŸ»"
    elif regime and 'Breakout' in regime:
        regime_color = "#ffa500"
        regime_emoji = "ğŸš€"
    else:
        regime_color = "#ffaa00"
        regime_emoji = "â†”ï¸"

    # Sentiment from spike if available
    if spike_data:
        spike_dir = spike_data.get('dominant_direction', 'NEUTRAL')
        spike_prob = spike_data.get('overall_spike_probability', 0)
        if spike_dir == 'UP' and spike_prob > 50:
            trading_sentiment = 'LONG' if spike_prob < 70 else 'STRONG LONG'
            sentiment_score = spike_prob
        elif spike_dir == 'DOWN' and spike_prob > 50:
            trading_sentiment = 'SHORT' if spike_prob < 70 else 'STRONG SHORT'
            sentiment_score = -spike_prob

    # Sentiment color
    if 'LONG' in trading_sentiment:
        sent_color = "#00ff00"
    elif 'SHORT' in trading_sentiment:
        sent_color = "#ff4444"
    else:
        sent_color = "#ffaa00"

    # Market phase explanation
    phase_explanations = {
        'Accumulation': "Smart money buying. Expect upward breakout soon.",
        'Markup': "Trending up. Follow the momentum, buy dips.",
        'Distribution': "Smart money selling. Expect downward breakdown.",
        'Markdown': "Trending down. Sell rallies, avoid longs.",
        'Consolidation': "Range-bound. Trade the range or wait for breakout.",
        'Breakout': "Breakout in progress. Follow the direction with momentum.",
        'Unknown': "Market in transition. Wait for clarity."
    }
    phase_explanation = phase_explanations.get(market_phase, "Market in transition phase.")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # COMPREHENSIVE SUPPORT/RESISTANCE (Option Chain Strike-Based + Chart)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PRIMARY: Option Chain Strike prices (50-point intervals)
    # SECONDARY: Chart-based levels that confirm/align with strikes

    support_levels = []
    resistance_levels = []

    # Get ATM Strike (primary reference)
    atm = signal.atm_strike if signal.atm_strike and signal.atm_strike > 0 else 0
    if not atm and spot_price:
        atm = round(spot_price / 50) * 50  # Round to nearest 50

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 1. PRIMARY: Option Chain Strike-Based S/R (50-point intervals)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if atm and spot_price:
        # Support strikes below spot (ATM-50, ATM-100, ATM-150, ATM-200)
        for offset in [50, 100, 150, 200]:
            strike = atm - offset
            if strike < spot_price:
                support_levels.append({'price': strike, 'source': 'Strike', 'type': f'CE-{offset}', 'priority': 1})

        # Resistance strikes above spot (ATM+50, ATM+100, ATM+150, ATM+200)
        for offset in [50, 100, 150, 200]:
            strike = atm + offset
            if strike > spot_price:
                resistance_levels.append({'price': strike, 'source': 'Strike', 'type': f'PE+{offset}', 'priority': 1})

        # ATM itself can be S or R
        if atm < spot_price:
            support_levels.append({'price': atm, 'source': 'ATM', 'type': 'ATM', 'priority': 1})
        elif atm > spot_price:
            resistance_levels.append({'price': atm, 'source': 'ATM', 'type': 'ATM', 'priority': 1})

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 2. Option Chain OI Data (Max OI strikes, Max Pain)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    option_data = st.session_state.get('overall_option_data', {}).get('NIFTY', {})
    if option_data:
        # Max OI PUT strike = Strong Support
        supp_data = option_data.get('support', {})
        if supp_data.get('strike'):
            strike = supp_data['strike']
            # Round to nearest 50 if not already
            strike = round(strike / 50) * 50
            if strike < spot_price:
                support_levels.append({'price': strike, 'source': 'OI-Wall', 'type': 'MaxPUT-OI', 'priority': 1})

        # Max OI CALL strike = Strong Resistance
        res_data = option_data.get('resistance', {})
        if res_data.get('strike'):
            strike = res_data['strike']
            strike = round(strike / 50) * 50
            if strike > spot_price:
                resistance_levels.append({'price': strike, 'source': 'OI-Wall', 'type': 'MaxCALL-OI', 'priority': 1})

        # Max Pain
        max_pain = option_data.get('max_pain')
        if max_pain and isinstance(max_pain, (int, float)):
            mp = round(max_pain / 50) * 50
            if mp < spot_price:
                support_levels.append({'price': mp, 'source': 'MaxPain', 'type': 'Target', 'priority': 1})
            else:
                resistance_levels.append({'price': mp, 'source': 'MaxPain', 'type': 'Target', 'priority': 1})

    # From Spike Detector (OI-based)
    if spike_data and spike_data.get('key_levels'):
        key_levels = spike_data.get('key_levels', {})
        if key_levels.get('support'):
            strike = round(key_levels['support'] / 50) * 50
            if strike < spot_price:
                support_levels.append({'price': strike, 'source': 'OI-Spike', 'type': 'Strike', 'priority': 1})
        if key_levels.get('resistance'):
            strike = round(key_levels['resistance'] / 50) * 50
            if strike > spot_price:
                resistance_levels.append({'price': strike, 'source': 'OI-Spike', 'type': 'Strike', 'priority': 1})

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 3. SECONDARY: Chart-based S/R (aligned to 50-point strikes)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if support_resistance:
        # Near Support/Resistance
        for key, src_type in [('near_support', 'Support'), ('major_support', 'Support'),
                               ('near_resistance', 'Resistance'), ('major_resistance', 'Resistance')]:
            value = support_resistance.get(key)
            if value and isinstance(value, (int, float)):
                # Align to nearest 50
                aligned = round(value / 50) * 50
                if 'support' in key.lower() and aligned < spot_price:
                    support_levels.append({'price': aligned, 'source': 'Chart', 'type': key.replace('_', '-'), 'priority': 2})
                elif 'resistance' in key.lower() and aligned > spot_price:
                    resistance_levels.append({'price': aligned, 'source': 'Chart', 'type': key.replace('_', '-'), 'priority': 2})

        # All swing supports/resistances
        for s in support_resistance.get('all_supports', []):
            if s and isinstance(s, (int, float)):
                aligned = round(s / 50) * 50
                if aligned < spot_price:
                    support_levels.append({'price': aligned, 'source': 'Chart', 'type': 'Swing', 'priority': 2})
        for r in support_resistance.get('all_resistances', []):
            if r and isinstance(r, (int, float)):
                aligned = round(r / 50) * 50
                if aligned > spot_price:
                    resistance_levels.append({'price': aligned, 'source': 'Chart', 'type': 'Swing', 'priority': 2})

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 4. ML Signal levels (aligned to 50-point strikes)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if signal.stop_loss and signal.stop_loss > 0:
        aligned = round(signal.stop_loss / 50) * 50
        if aligned < spot_price:
            support_levels.append({'price': aligned, 'source': 'ML', 'type': 'StopLoss', 'priority': 2})

    if signal.targets:
        for i, tgt in enumerate(signal.targets[:2]):
            if tgt and tgt > 0:
                aligned = round(tgt / 50) * 50
                if aligned > spot_price:
                    resistance_levels.append({'price': aligned, 'source': 'ML', 'type': f'Target{i+1}', 'priority': 2})

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 5. Merge and consolidate levels at same strike (within 25 points)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    def merge_sr_levels(levels, merge_threshold=25):
        """Merge levels within threshold. Since all levels are 50-point aligned,
        threshold of 25 will only merge exact matches."""
        if not levels:
            return []

        # Sort by price
        sorted_levels = sorted(levels, key=lambda x: x['price'])
        merged = []
        current_zone = None

        for lvl in sorted_levels:
            if current_zone is None:
                current_zone = {
                    'prices': [lvl['price']],
                    'sources': [lvl['source']],
                    'types': [lvl.get('type', 'Unknown')],
                    'priority': lvl.get('priority', 2)
                }
            elif abs(lvl['price'] - current_zone['prices'][-1]) <= merge_threshold:
                # Same strike - merge and count confluence
                current_zone['prices'].append(lvl['price'])
                if lvl['source'] not in current_zone['sources']:
                    current_zone['sources'].append(lvl['source'])
                if lvl.get('type') and lvl['type'] not in current_zone['types']:
                    current_zone['types'].append(lvl['type'])
                # Keep highest priority (lower number = higher priority)
                current_zone['priority'] = min(current_zone['priority'], lvl.get('priority', 2))
            else:
                # New strike level
                avg_price = round(sum(current_zone['prices']) / len(current_zone['prices']) / 50) * 50
                merged.append({
                    'price': avg_price,
                    'range': (min(current_zone['prices']), max(current_zone['prices'])),
                    'sources': current_zone['sources'],
                    'strength': len(current_zone['sources']),  # Confluence count
                    'priority': current_zone['priority']
                })
                current_zone = {
                    'prices': [lvl['price']],
                    'sources': [lvl['source']],
                    'types': [lvl.get('type', 'Unknown')],
                    'priority': lvl.get('priority', 2)
                }

        # Don't forget last zone
        if current_zone:
            avg_price = round(sum(current_zone['prices']) / len(current_zone['prices']) / 50) * 50
            merged.append({
                'price': avg_price,
                'range': (min(current_zone['prices']), max(current_zone['prices'])),
                'sources': current_zone['sources'],
                'strength': len(current_zone['sources']),
                'priority': current_zone['priority']
            })
        return merged

    merged_supports = merge_sr_levels(support_levels)
    merged_resistances = merge_sr_levels(resistance_levels)

    # Sort by: 1) Priority (Option Chain first), 2) Strength (confluence), 3) Proximity to spot
    if spot_price:
        merged_supports = sorted(merged_supports,
            key=lambda x: (x.get('priority', 2), -x['strength'], spot_price - x['price']))[:3]
        merged_resistances = sorted(merged_resistances,
            key=lambda x: (x.get('priority', 2), -x['strength'], x['price'] - spot_price))[:3]

    # FALLBACK: If still no S/R, calculate from spot price
    if not merged_supports and spot_price and spot_price > 0:
        # Use round numbers as support
        base = int(spot_price / 50) * 50  # Round to nearest 50
        merged_supports = [
            {'price': base - 50, 'range': (base - 50, base - 50), 'sources': ['Calculated'], 'strength': 1},
            {'price': base - 100, 'range': (base - 100, base - 100), 'sources': ['Calculated'], 'strength': 1}
        ]
    if not merged_resistances and spot_price and spot_price > 0:
        base = int(spot_price / 50) * 50  # Round to nearest 50
        merged_resistances = [
            {'price': base + 50, 'range': (base + 50, base + 50), 'sources': ['Calculated'], 'strength': 1},
            {'price': base + 100, 'range': (base + 100, base + 100), 'sources': ['Calculated'], 'strength': 1}
        ]

    # Get primary S/R for display
    support = merged_supports[0]['price'] if merged_supports else 0
    resistance = merged_resistances[0]['price'] if merged_resistances else 0

    # Build signals text
    signals_text = ""
    if signals_list:
        for sig in signals_list[:4]:
            sig_color = "#00ff00" if "bull" in sig.lower() or "buy" in sig.lower() or "up" in sig.lower() else "#ff4444" if "bear" in sig.lower() or "sell" in sig.lower() or "down" in sig.lower() else "#aaa"
            signals_text += f'<span style="color: {sig_color};">â€¢ {sig}</span><br>'

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ML MARKET REGIME ASSESSMENT - Using Streamlit Components
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    st.markdown("---")
    st.subheader("ğŸ“Š ML MARKET REGIME ASSESSMENT")

    # Row 1: Regime and Confidence
    col1, col2 = st.columns(2)
    with col1:
        st.metric(label="Market Regime", value=f"{regime_emoji} {regime}")
    with col2:
        st.metric(label="Confidence", value=f"{confidence:.0f}%")

    # Row 2: Market Phase and Sentiment
    col3, col4 = st.columns(2)
    with col3:
        st.markdown(f"**Market Phase:** {market_phase}")
        st.caption(f"ğŸ’¡ {phase_explanation}")
    with col4:
        sent_emoji = "ğŸŸ¢" if "LONG" in str(trading_sentiment) else "ğŸ”´" if "SHORT" in str(trading_sentiment) else "ğŸŸ¡"
        st.markdown(f"**Trading Sentiment:** {sent_emoji} {trading_sentiment}")
        st.caption(f"Score: {sentiment_score:+.0f}")

    # Row 3: Technical Details
    col5, col6, col7 = st.columns(3)
    with col5:
        st.markdown(f"**Trend Strength:** {trend_strength:.0f}%")
    with col6:
        st.markdown(f"**Volatility:** {volatility_state}")
    with col7:
        st.markdown(f"**Timeframe:** {optimal_timeframe}")

    # Row 4: Trading Range (S/R from Option Chain + Chart)
    primary_supp = merged_supports[0]['price'] if merged_supports else 0
    primary_res = merged_resistances[0]['price'] if merged_resistances else 0
    range_size = abs(primary_res - primary_supp) if primary_supp and primary_res else 0

    if primary_supp > 0 or primary_res > 0:
        st.markdown("---")
        st.markdown("**ğŸ“Š TRADING RANGE (OI + Chart Aligned)**")
        col_s, col_r, col_range = st.columns(3)
        with col_s:
            supp_sources = " + ".join(merged_supports[0]['sources']) if merged_supports else "N/A"
            st.metric("ğŸ›¡ï¸ Support", f"â‚¹{primary_supp:,.0f}", delta=None, help=f"Sources: {supp_sources}")
        with col_r:
            res_sources = " + ".join(merged_resistances[0]['sources']) if merged_resistances else "N/A"
            st.metric("ğŸ§± Resistance", f"â‚¹{primary_res:,.0f}", delta=None, help=f"Sources: {res_sources}")
        with col_range:
            st.metric("ğŸ“ Range", f"{range_size:,.0f} pts", delta=None)

        # Show current position in range
        if spot_price and primary_supp and primary_res and range_size > 0:
            position_pct = ((spot_price - primary_supp) / range_size) * 100
            position_pct = max(0, min(100, position_pct))  # Clamp 0-100
            if position_pct > 70:
                st.warning(f"âš ï¸ Price near RESISTANCE ({position_pct:.0f}% of range) - Watch for rejection")
            elif position_pct < 30:
                st.warning(f"âš ï¸ Price near SUPPORT ({position_pct:.0f}% of range) - Watch for bounce")
            else:
                st.info(f"ğŸ“ Price at {position_pct:.0f}% of range (Mid-zone)")

    # Recommended Strategy
    st.info(f"ğŸ“Œ **Recommended Strategy:** {recommended_strategy}")

    # Signals list
    if signals_list:
        with st.expander("ğŸ“¡ Active Signals", expanded=False):
            for sig in signals_list[:4]:
                if "bull" in sig.lower() or "buy" in sig.lower() or "up" in sig.lower():
                    st.success(f"â€¢ {sig}")
                elif "bear" in sig.lower() or "sell" in sig.lower() or "down" in sig.lower():
                    st.error(f"â€¢ {sig}")
                else:
                    st.write(f"â€¢ {sig}")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ“Š COMPREHENSIVE SUPPORT/RESISTANCE DISPLAY - Python Components
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if merged_supports or merged_resistances:
        st.markdown("---")
        st.subheader("ğŸ“Š SUPPORT & RESISTANCE ZONES")
        st.caption("Chart + OI Aligned | More â–ˆ = Stronger confluence")

        col_s, col_r = st.columns(2)

        with col_s:
            st.markdown("**ğŸ›¡ï¸ SUPPORT ZONES**")
            if merged_supports:
                for i, s in enumerate(merged_supports[:3]):
                    strength_bars = "â–ˆ" * min(s['strength'], 5)
                    sources = " + ".join(s['sources'])
                    zone_range = f"â‚¹{s['range'][0]:,.0f} - â‚¹{s['range'][1]:,.0f}" if s['range'][0] != s['range'][1] else f"â‚¹{s['price']:,.0f}"
                    st.success(f"S{i+1}: {zone_range} ({sources}) {strength_bars}")
            else:
                st.caption("No support levels detected")

        with col_r:
            st.markdown("**ğŸ§± RESISTANCE ZONES**")
            if merged_resistances:
                for i, r in enumerate(merged_resistances[:3]):
                    strength_bars = "â–ˆ" * min(r['strength'], 5)
                    sources = " + ".join(r['sources'])
                    zone_range = f"â‚¹{r['range'][0]:,.0f} - â‚¹{r['range'][1]:,.0f}" if r['range'][0] != r['range'][1] else f"â‚¹{r['price']:,.0f}"
                    st.error(f"R{i+1}: {zone_range} ({sources}) {strength_bars}")
            else:
                st.caption("No resistance levels detected")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ğŸ¯ FINAL ASSESSMENT - Clear Directional Call
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # Determine overall market direction
    is_bullish = signal.signal in ['STRONG BUY', 'BUY'] or (trading_sentiment and 'LONG' in trading_sentiment)
    is_bearish = signal.signal in ['STRONG SELL', 'SELL'] or (trading_sentiment and 'SHORT' in trading_sentiment)

    # Get key levels
    primary_support = merged_supports[0]['price'] if merged_supports else 0
    primary_resistance = merged_resistances[0]['price'] if merged_resistances else 0
    current_price = spot_price or 0

    # Calculate distances
    dist_to_support = abs(current_price - primary_support) if primary_support and current_price else 999
    dist_to_resistance = abs(primary_resistance - current_price) if primary_resistance and current_price else 999

    # Determine if near key level (within 30 points)
    near_support = dist_to_support < 30
    near_resistance = dist_to_resistance < 30

    # Build assessment
    if is_bullish:
        direction_color = "#00ff00"
        direction_emoji = "ğŸ‚"
        direction_text = "BULLISH"

        if near_resistance:
            # Bullish but near resistance - potential reversal
            assessment_text = f"âš ï¸ CAUTION: Market is BULLISH but approaching RESISTANCE at â‚¹{primary_resistance:,.0f}. Watch for reversal or breakout."
            move_text = f"If breakout above â‚¹{primary_resistance:,.0f} â†’ Next target: â‚¹{primary_resistance + 100:,.0f}"
            reversal_text = f"If rejection at â‚¹{primary_resistance:,.0f} â†’ Pullback to â‚¹{primary_support:,.0f}"
        else:
            assessment_text = f"ğŸ“ˆ Market will RISE from Support â‚¹{primary_support:,.0f} towards Resistance â‚¹{primary_resistance:,.0f}"
            move_text = f"Expected Move: â‚¹{primary_support:,.0f} â†’ â‚¹{primary_resistance:,.0f} ({primary_resistance - primary_support:,.0f} points)"
            reversal_text = f"ğŸ”„ Reversal Zone: If price falls below â‚¹{primary_support:,.0f}, trend may reverse to BEARISH"

    elif is_bearish:
        direction_color = "#ff4444"
        direction_emoji = "ğŸ»"
        direction_text = "BEARISH"

        if near_support:
            # Bearish but near support - potential reversal
            assessment_text = f"âš ï¸ CAUTION: Market is BEARISH but approaching SUPPORT at â‚¹{primary_support:,.0f}. Watch for reversal or breakdown."
            move_text = f"If breakdown below â‚¹{primary_support:,.0f} â†’ Next target: â‚¹{primary_support - 100:,.0f}"
            reversal_text = f"If bounce from â‚¹{primary_support:,.0f} â†’ Rally to â‚¹{primary_resistance:,.0f}"
        else:
            assessment_text = f"ğŸ“‰ Market will FALL from Resistance â‚¹{primary_resistance:,.0f} towards Support â‚¹{primary_support:,.0f}"
            move_text = f"Expected Move: â‚¹{primary_resistance:,.0f} â†’ â‚¹{primary_support:,.0f} ({primary_resistance - primary_support:,.0f} points)"
            reversal_text = f"ğŸ”„ Reversal Zone: If price rises above â‚¹{primary_resistance:,.0f}, trend may reverse to BULLISH"

    else:
        direction_color = "#ffaa00"
        direction_emoji = "â†”ï¸"
        direction_text = "NEUTRAL/RANGE"
        assessment_text = f"â†”ï¸ Market is RANGE-BOUND between â‚¹{primary_support:,.0f} and â‚¹{primary_resistance:,.0f}"
        move_text = f"Trade the Range: BUY near â‚¹{primary_support:,.0f} | SELL near â‚¹{primary_resistance:,.0f}"
        reversal_text = f"ğŸš€ Breakout Watch: Above â‚¹{primary_resistance:,.0f} = BULLISH | Below â‚¹{primary_support:,.0f} = BEARISH"

    if primary_support > 0 or primary_resistance > 0:
        st.markdown("---")
        st.subheader("ğŸ¯ FINAL ASSESSMENT")

        # Direction badge
        col_dir, col_badge = st.columns([3, 1])
        with col_dir:
            st.markdown(f"**Direction:** {direction_emoji} **{direction_text}**")
        with col_badge:
            if is_bullish:
                st.success(f"{direction_emoji} {direction_text}")
            elif is_bearish:
                st.error(f"{direction_emoji} {direction_text}")
            else:
                st.warning(f"{direction_emoji} {direction_text}")

        # Assessment text
        if is_bullish:
            if near_resistance:
                st.warning(assessment_text)
            else:
                st.success(assessment_text)
        elif is_bearish:
            if near_support:
                st.warning(assessment_text)
            else:
                st.error(assessment_text)
        else:
            st.info(assessment_text)

        # Move and Reversal
        st.markdown(f"**ğŸ“Š {move_text}**")
        st.caption(reversal_text)

        # Distance metrics
        col_p1, col_p2, col_p3 = st.columns(3)
        with col_p1:
            st.metric("Current Price", f"â‚¹{current_price:,.0f}")
        with col_p2:
            st.metric("To Support", f"{dist_to_support:,.0f} pts", delta=None)
        with col_p3:
            st.metric("To Resistance", f"{dist_to_resistance:,.0f} pts", delta=None)

    # Show ATM Option Recommendation based on signal
    st.markdown("---")
    if signal.signal in ['STRONG BUY', 'BUY'] and signal.atm_call_ltp > 0:
        st.subheader("ğŸ“ˆ BUY ATM CALL")
        col_atm1, col_atm2 = st.columns(2)
        with col_atm1:
            st.metric("Strike", f"â‚¹{signal.atm_strike:,.0f}")
        with col_atm2:
            st.metric("LTP", f"â‚¹{signal.atm_call_ltp:,.2f}")
        st.success(f"**RECOMMENDATION:** BUY {signal.atm_strike:.0f} CE @ â‚¹{signal.atm_call_ltp:.2f}")

    elif signal.signal in ['STRONG SELL', 'SELL'] and signal.atm_put_ltp > 0:
        st.subheader("ğŸ“‰ BUY ATM PUT")
        col_atm1, col_atm2 = st.columns(2)
        with col_atm1:
            st.metric("Strike", f"â‚¹{signal.atm_strike:,.0f}")
        with col_atm2:
            st.metric("LTP", f"â‚¹{signal.atm_put_ltp:,.2f}")
        st.error(f"**RECOMMENDATION:** BUY {signal.atm_strike:.0f} PE @ â‚¹{signal.atm_put_ltp:.2f}")

    # Send to Telegram for BUY/SELL signals (with auto-send option)
    if signal.signal in ['STRONG BUY', 'BUY', 'STRONG SELL', 'SELL']:
        tg_col1, tg_col2 = st.columns([3, 1])
        with tg_col1:
            auto_send = st.checkbox("ğŸ“± Auto-send to Telegram", value=True, key="ml_signal_auto_telegram")
        with tg_col2:
            manual_send = st.button("ğŸ“¤ Send Now", key="ml_signal_manual_telegram")

        # Auto-send or manual send
        if auto_send or manual_send:
            success, msg = send_ml_signal_telegram(signal, spot_price)
            if success:
                st.success(f"âœ… {msg}")
            elif "already sent" not in msg.lower() and "not configured" not in msg.lower():
                st.warning(f"âš ï¸ {msg}")

    # Metrics row 1
    col1, col2, col3, col4, col5, col6 = st.columns(6)

    with col1:
        st.metric("Regime", signal.regime, f"{signal.regime_score:+.0f}")

    with col2:
        st.metric("Volatility", signal.volatility_state, f"{signal.volatility_score:.0f}%")

    with col3:
        st.metric("OI Trap", signal.trap_warning[:12], f"{signal.oi_trap_score:+.0f}")

    with col4:
        st.metric("CVD", f"{signal.cvd_score:+.0f}", "Bull" if signal.cvd_score > 0 else "Bear" if signal.cvd_score < 0 else "-")

    with col5:
        st.metric("Expiry", f"{signal.days_to_expiry:.1f}d", signal.expiry_warning[:10])

    with col6:
        st.metric("Position", f"{signal.position_size_multiplier:.1f}x", signal.risk_level)

    st.divider()

    # Strategy recommendation
    st.info(f"ğŸ“Š **Strategy:** {signal.recommended_strategy}")

    # Entry/Exit levels
    if signal.signal != "HOLD" and spot_price:
        col1, col2 = st.columns(2)

        with col1:
            st.markdown("### ğŸ¯ Entry Zone")
            st.write(f"**Entry:** â‚¹{signal.entry_zone[0]:,.0f} - â‚¹{signal.entry_zone[1]:,.0f}")
            st.write(f"**Stop Loss:** â‚¹{signal.stop_loss:,.0f}")

        with col2:
            st.markdown("### ğŸ¯ Targets")
            for i, target in enumerate(signal.targets, 1):
                st.write(f"**T{i}:** â‚¹{target:,.0f}")

    # Reasons
    col1, col2 = st.columns(2)

    with col1:
        if signal.bullish_reasons:
            st.markdown("### ğŸ‚ Bullish Signals")
            for reason in signal.bullish_reasons:
                st.success(f"âœ… {reason}")

    with col2:
        if signal.bearish_reasons:
            st.markdown("### ğŸ» Bearish Signals")
            for reason in signal.bearish_reasons:
                st.error(f"âš ï¸ {reason}")

    # Component scores chart
    with st.expander("ğŸ“Š Component Scores Breakdown"):
        scores_df = pd.DataFrame({
            'Component': ['Regime', 'XGBoost', 'Volatility', 'OI Trap', 'CVD', 'Liquidity'],
            'Score': [
                signal.regime_score,
                signal.xgboost_score,
                signal.volatility_score - 50,  # Normalize to -50 to +50
                signal.oi_trap_score,
                signal.cvd_score,
                signal.liquidity_score
            ]
        })

        import plotly.express as px
        fig = px.bar(
            scores_df,
            x='Component',
            y='Score',
            color='Score',
            color_continuous_scale=['red', 'yellow', 'green'],
            range_color=[-100, 100]
        )
        fig.update_layout(height=300)
        st.plotly_chart(fig, use_container_width=True)


def get_cached_unified_signal() -> Optional[UnifiedSignal]:
    """Get cached unified signal from session state"""
    return st.session_state.get('unified_ml_signal')
